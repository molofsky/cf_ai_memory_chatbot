import { MessageType } from "../ai-types-UZlfLOYP.js";
import "../client-DjR-lC16.js";
import { SSEEdgeClientTransport, StreamableHTTPEdgeClientTransport } from "../client-CZBVDDoO.js";
import "../do-oauth-client-provider-B2jr6UNq.js";
import { Agent, getAgentByName, getCurrentAgent } from "../src-L3cHuAag.js";
import { ElicitRequestSchema, InitializeRequestSchema, JSONRPCMessageSchema, isJSONRPCError, isJSONRPCNotification, isJSONRPCRequest, isJSONRPCResponse } from "@modelcontextprotocol/sdk/types.js";

//#region src/mcp/utils.ts
/**
* Since we use WebSockets to bridge the client to the
* MCP transport in the Agent, we use this header to signal
* the method of the original request the user made, while
* leaving the WS Upgrade request as GET.
*/
const MCP_HTTP_METHOD_HEADER = "cf-mcp-method";
/**
* Since we use WebSockets to bridge the client to the
* MCP transport in the Agent, we use this header to include
* the original request body.
*/
const MCP_MESSAGE_HEADER = "cf-mcp-message";
const MAXIMUM_MESSAGE_SIZE_BYTES = 4 * 1024 * 1024;
const createStreamingHttpHandler = (basePath, namespace, corsOptions) => {
	let pathname = basePath;
	if (basePath === "/") pathname = "/*";
	const basePattern = new URLPattern({ pathname });
	return async (request, ctx) => {
		const url = new URL(request.url);
		if (basePattern.test(url)) {
			if (request.method === "POST") {
				const acceptHeader = request.headers.get("accept");
				if (!acceptHeader?.includes("application/json") || !acceptHeader.includes("text/event-stream")) {
					const body$1 = JSON.stringify({
						error: {
							code: -32e3,
							message: "Not Acceptable: Client must accept both application/json and text/event-stream"
						},
						id: null,
						jsonrpc: "2.0"
					});
					return new Response(body$1, { status: 406 });
				}
				const ct = request.headers.get("content-type");
				if (!ct || !ct.includes("application/json")) {
					const body$1 = JSON.stringify({
						error: {
							code: -32e3,
							message: "Unsupported Media Type: Content-Type must be application/json"
						},
						id: null,
						jsonrpc: "2.0"
					});
					return new Response(body$1, { status: 415 });
				}
				if (Number.parseInt(request.headers.get("content-length") ?? "0", 10) > MAXIMUM_MESSAGE_SIZE_BYTES) {
					const body$1 = JSON.stringify({
						error: {
							code: -32e3,
							message: `Request body too large. Maximum size is ${MAXIMUM_MESSAGE_SIZE_BYTES} bytes`
						},
						id: null,
						jsonrpc: "2.0"
					});
					return new Response(body$1, { status: 413 });
				}
				let sessionId = request.headers.get("mcp-session-id");
				let rawMessage;
				try {
					rawMessage = await request.json();
				} catch (_error) {
					const body$1 = JSON.stringify({
						error: {
							code: -32700,
							message: "Parse error: Invalid JSON"
						},
						id: null,
						jsonrpc: "2.0"
					});
					return new Response(body$1, { status: 400 });
				}
				let arrayMessage;
				if (Array.isArray(rawMessage)) arrayMessage = rawMessage;
				else arrayMessage = [rawMessage];
				let messages = [];
				for (const msg of arrayMessage) if (!JSONRPCMessageSchema.safeParse(msg).success) {
					const body$1 = JSON.stringify({
						error: {
							code: -32700,
							message: "Parse error: Invalid JSON-RPC message"
						},
						id: null,
						jsonrpc: "2.0"
					});
					return new Response(body$1, { status: 400 });
				}
				messages = arrayMessage.map((msg) => JSONRPCMessageSchema.parse(msg));
				const maybeInitializeRequest = messages.find((msg) => InitializeRequestSchema.safeParse(msg).success);
				if (!!maybeInitializeRequest && sessionId) {
					const body$1 = JSON.stringify({
						error: {
							code: -32600,
							message: "Invalid Request: Initialization requests must not include a sessionId"
						},
						id: null,
						jsonrpc: "2.0"
					});
					return new Response(body$1, { status: 400 });
				}
				if (!!maybeInitializeRequest && messages.length > 1) {
					const body$1 = JSON.stringify({
						error: {
							code: -32600,
							message: "Invalid Request: Only one initialization request is allowed"
						},
						id: null,
						jsonrpc: "2.0"
					});
					return new Response(body$1, { status: 400 });
				}
				if (!maybeInitializeRequest && !sessionId) {
					const body$1 = JSON.stringify({
						error: {
							code: -32e3,
							message: "Bad Request: Mcp-Session-Id header is required"
						},
						id: null,
						jsonrpc: "2.0"
					});
					return new Response(body$1, { status: 400 });
				}
				sessionId = sessionId ?? namespace.newUniqueId().toString();
				const agent = await getAgentByName(namespace, `streamable-http:${sessionId}`, { props: ctx.props });
				const isInitialized = await agent.getInitializeRequest();
				if (maybeInitializeRequest) await agent.setInitializeRequest(maybeInitializeRequest);
				else if (!isInitialized) {
					const body$1 = JSON.stringify({
						error: {
							code: -32001,
							message: "Session not found"
						},
						id: null,
						jsonrpc: "2.0"
					});
					return new Response(body$1, { status: 404 });
				}
				const { readable, writable } = new TransformStream();
				const writer = writable.getWriter();
				const encoder = new TextEncoder();
				const existingHeaders = {};
				request.headers.forEach((value, key) => {
					existingHeaders[key] = value;
				});
				const req = new Request(request.url, { headers: {
					...existingHeaders,
					[MCP_HTTP_METHOD_HEADER]: "POST",
					[MCP_MESSAGE_HEADER]: Buffer.from(JSON.stringify(messages)).toString("base64"),
					Upgrade: "websocket"
				} });
				if (ctx.props) agent.updateProps(ctx.props);
				const ws = (await agent.fetch(req)).webSocket;
				if (!ws) {
					console.error("Failed to establish WebSocket connection");
					await writer.close();
					const body$1 = JSON.stringify({
						error: {
							code: -32001,
							message: "Failed to establish WebSocket connection"
						},
						id: null,
						jsonrpc: "2.0"
					});
					return new Response(body$1, { status: 500 });
				}
				ws.accept();
				ws.addEventListener("message", (event) => {
					async function onMessage(event$1) {
						try {
							const data = typeof event$1.data === "string" ? event$1.data : new TextDecoder().decode(event$1.data);
							const message = JSON.parse(data);
							if (message.type !== MessageType.CF_MCP_AGENT_EVENT) return;
							await writer.write(encoder.encode(message.event));
							if (message.close) {
								ws?.close();
								await writer.close().catch(() => {});
							}
						} catch (error) {
							console.error("Error forwarding message to SSE:", error);
						}
					}
					onMessage(event).catch(console.error);
				});
				ws.addEventListener("error", (error) => {
					async function onError(_error) {
						await writer.close().catch(() => {});
					}
					onError(error).catch(console.error);
				});
				ws.addEventListener("close", () => {
					async function onClose() {
						await writer.close().catch(() => {});
					}
					onClose().catch(console.error);
				});
				if (messages.every((msg) => isJSONRPCNotification(msg) || isJSONRPCResponse(msg))) {
					ws.close();
					return new Response(null, {
						headers: corsHeaders(request, corsOptions),
						status: 202
					});
				}
				return new Response(readable, {
					headers: {
						"Cache-Control": "no-cache",
						Connection: "keep-alive",
						"Content-Type": "text/event-stream",
						"mcp-session-id": sessionId,
						...corsHeaders(request, corsOptions)
					},
					status: 200
				});
			} else if (request.method === "GET") {
				if (!request.headers.get("accept")?.includes("text/event-stream")) {
					const body$1 = JSON.stringify({
						jsonrpc: "2.0",
						error: {
							code: -32e3,
							message: "Not Acceptable: Client must accept text/event-stream"
						},
						id: null
					});
					return new Response(body$1, { status: 406 });
				}
				const sessionId = request.headers.get("mcp-session-id");
				if (!sessionId) return new Response(JSON.stringify({
					error: {
						code: -32e3,
						message: "Bad Request: Mcp-Session-Id header is required"
					},
					id: null,
					jsonrpc: "2.0"
				}), { status: 400 });
				const { readable, writable } = new TransformStream();
				const writer = writable.getWriter();
				const encoder = new TextEncoder();
				const agent = await getAgentByName(namespace, `streamable-http:${sessionId}`, { props: ctx.props });
				if (!await agent.getInitializeRequest()) return new Response(JSON.stringify({
					jsonrpc: "2.0",
					error: {
						code: -32001,
						message: "Session not found"
					},
					id: null
				}), { status: 404 });
				const existingHeaders = {};
				request.headers.forEach((v, k) => {
					existingHeaders[k] = v;
				});
				if (ctx.props) agent.updateProps(ctx.props);
				const ws = (await agent.fetch(new Request(request.url, { headers: {
					...existingHeaders,
					[MCP_HTTP_METHOD_HEADER]: "GET",
					Upgrade: "websocket"
				} }))).webSocket;
				if (!ws) {
					await writer.close();
					return new Response("Failed to establish WS to DO", { status: 500 });
				}
				ws.accept();
				ws.addEventListener("message", (event) => {
					try {
						async function onMessage(ev) {
							const data = typeof ev.data === "string" ? ev.data : new TextDecoder().decode(ev.data);
							const message = JSON.parse(data);
							if (message.type !== MessageType.CF_MCP_AGENT_EVENT) return;
							await writer.write(encoder.encode(message.event));
						}
						onMessage(event).catch(console.error);
					} catch (e) {
						console.error("Error forwarding message to SSE:", e);
					}
				});
				ws.addEventListener("error", () => {
					writer.close().catch(() => {});
				});
				ws.addEventListener("close", () => {
					writer.close().catch(() => {});
				});
				return new Response(readable, {
					headers: {
						"Cache-Control": "no-cache",
						Connection: "keep-alive",
						"Content-Type": "text/event-stream",
						"mcp-session-id": sessionId,
						...corsHeaders(request, corsOptions)
					},
					status: 200
				});
			} else if (request.method === "DELETE") {
				const sessionId = request.headers.get("mcp-session-id");
				if (!sessionId) return new Response(JSON.stringify({
					jsonrpc: "2.0",
					error: {
						code: -32e3,
						message: "Bad Request: Mcp-Session-Id header is required"
					},
					id: null
				}), {
					status: 400,
					headers: corsHeaders(request, corsOptions)
				});
				const agent = await getAgentByName(namespace, `streamable-http:${sessionId}`);
				if (!await agent.getInitializeRequest()) return new Response(JSON.stringify({
					jsonrpc: "2.0",
					error: {
						code: -32001,
						message: "Session not found"
					},
					id: null
				}), {
					status: 404,
					headers: corsHeaders(request, corsOptions)
				});
				ctx.waitUntil(agent.destroy().catch(() => {}));
				return new Response(null, {
					status: 204,
					headers: corsHeaders(request, corsOptions)
				});
			}
		}
		const body = JSON.stringify({
			error: {
				code: -32e3,
				message: "Not found"
			},
			id: null,
			jsonrpc: "2.0"
		});
		return new Response(body, { status: 404 });
	};
};
const createLegacySseHandler = (basePath, namespace, corsOptions) => {
	let pathname = basePath;
	if (basePath === "/") pathname = "/*";
	const basePattern = new URLPattern({ pathname });
	const messagePattern = new URLPattern({ pathname: `${basePath}/message` });
	return async (request, ctx) => {
		const url = new URL(request.url);
		if (request.method === "GET" && basePattern.test(url)) {
			const sessionId = url.searchParams.get("sessionId") || namespace.newUniqueId().toString();
			const { readable, writable } = new TransformStream();
			const writer = writable.getWriter();
			const encoder = new TextEncoder();
			const endpointUrl = new URL(request.url);
			endpointUrl.pathname = encodeURI(`${basePath}/message`);
			endpointUrl.searchParams.set("sessionId", sessionId);
			const endpointMessage = `event: endpoint\ndata: ${endpointUrl.pathname + endpointUrl.search + endpointUrl.hash}\n\n`;
			writer.write(encoder.encode(endpointMessage));
			const agent = await getAgentByName(namespace, `sse:${sessionId}`, { props: ctx.props });
			const existingHeaders = {};
			request.headers.forEach((value, key) => {
				existingHeaders[key] = value;
			});
			if (ctx.props) agent.updateProps(ctx.props);
			const ws = (await agent.fetch(new Request(request.url, { headers: {
				...existingHeaders,
				Upgrade: "websocket"
			} }))).webSocket;
			if (!ws) {
				console.error("Failed to establish WebSocket connection");
				await writer.close();
				return new Response("Failed to establish WebSocket connection", { status: 500 });
			}
			ws.accept();
			ws.addEventListener("message", (event) => {
				async function onMessage(event$1) {
					try {
						const message = JSON.parse(event$1.data);
						const result = JSONRPCMessageSchema.safeParse(message);
						if (!result.success) return;
						const messageText = `event: message\ndata: ${JSON.stringify(result.data)}\n\n`;
						await writer.write(encoder.encode(messageText));
					} catch (error) {
						console.error("Error forwarding message to SSE:", error);
					}
				}
				onMessage(event).catch(console.error);
			});
			ws.addEventListener("error", (error) => {
				async function onError(_error) {
					try {
						await writer.close();
					} catch (_e) {}
				}
				onError(error).catch(console.error);
			});
			ws.addEventListener("close", () => {
				async function onClose() {
					try {
						await writer.close();
					} catch (error) {
						console.error("Error closing SSE connection:", error);
					}
				}
				onClose().catch(console.error);
			});
			return new Response(readable, { headers: {
				"Cache-Control": "no-cache",
				Connection: "keep-alive",
				"Content-Type": "text/event-stream",
				...corsHeaders(request, corsOptions)
			} });
		}
		if (request.method === "POST" && messagePattern.test(url)) {
			const sessionId = url.searchParams.get("sessionId");
			if (!sessionId) return new Response(`Missing sessionId. Expected POST to ${basePath} to initiate new one`, { status: 400 });
			const contentType = request.headers.get("content-type") || "";
			if (!contentType.includes("application/json")) return new Response(`Unsupported content-type: ${contentType}`, { status: 400 });
			const contentLength = Number.parseInt(request.headers.get("content-length") || "0", 10);
			if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) return new Response(`Request body too large: ${contentLength} bytes`, { status: 400 });
			const agent = await getAgentByName(namespace, `sse:${sessionId}`, { props: ctx.props });
			const messageBody = await request.json();
			const error = await agent.onSSEMcpMessage(sessionId, messageBody);
			if (error) return new Response(error.message, {
				headers: {
					"Cache-Control": "no-cache",
					Connection: "keep-alive",
					"Content-Type": "text/event-stream",
					...corsHeaders(request, corsOptions)
				},
				status: 400
			});
			return new Response("Accepted", {
				headers: {
					"Cache-Control": "no-cache",
					Connection: "keep-alive",
					"Content-Type": "text/event-stream",
					...corsHeaders(request, corsOptions)
				},
				status: 202
			});
		}
		return new Response("Not Found", { status: 404 });
	};
};
function corsHeaders(_request, corsOptions = {}) {
	const origin = "*";
	return {
		"Access-Control-Allow-Headers": corsOptions.headers || "Content-Type, Accept, mcp-session-id, mcp-protocol-version",
		"Access-Control-Allow-Methods": corsOptions.methods || "GET, POST, DELETE, OPTIONS",
		"Access-Control-Allow-Origin": corsOptions.origin || origin,
		"Access-Control-Expose-Headers": corsOptions.exposeHeaders || "mcp-session-id",
		"Access-Control-Max-Age": (corsOptions.maxAge || 86400).toString()
	};
}
function handleCORS(request, corsOptions) {
	if (request.method === "OPTIONS") return new Response(null, { headers: corsHeaders(request, corsOptions) });
	return null;
}
function isDurableObjectNamespace(namespace) {
	return typeof namespace === "object" && namespace !== null && "newUniqueId" in namespace && typeof namespace.newUniqueId === "function" && "idFromName" in namespace && typeof namespace.idFromName === "function";
}

//#endregion
//#region src/mcp/transport.ts
var McpSSETransport = class {
	constructor(getWebSocket) {
		this._started = false;
		this._getWebSocket = getWebSocket;
	}
	async start() {
		if (this._started) throw new Error("Transport already started");
		this._started = true;
	}
	async send(message) {
		if (!this._started) throw new Error("Transport not started");
		const websocket = this._getWebSocket();
		if (!websocket) throw new Error("WebSocket not connected");
		try {
			websocket.send(JSON.stringify(message));
		} catch (error) {
			this.onerror?.(error);
		}
	}
	async close() {
		this.onclose?.();
	}
};
/**
* Adapted from: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/client/streamableHttp.ts
* - Validation and initialization are removed as they're handled in `McpAgent.serve()` handler.
* - Replaces the Node-style `req`/`res` with Worker's `Request`.
* - Writes events as WS messages that the Worker forwards to the client as SSE events.
* - Replaces the in-memory maps that track requestID/stream by using `connection.setState()` and `agent.getConnections()`.
*
* Besides these points, the implementation is the same and should be updated to match the original as new features are added.
*/
var StreamableHTTPServerTransport = class {
	constructor(options) {
		this._started = false;
		this._requestResponseMap = /* @__PURE__ */ new Map();
		const { agent } = getCurrentAgent();
		if (!agent) throw new Error("McpAgent was not found in Transport constructor");
		this.sessionId = agent.getSessionId();
		this._eventStore = options.eventStore;
	}
	/**
	* Starts the transport. This is required by the Transport interface but is a no-op
	* for the Streamable HTTP transport as connections are managed per-request.
	*/
	async start() {
		if (this._started) throw new Error("Transport already started");
		this._started = true;
	}
	/**
	* Handles GET requests for SSE stream
	*/
	async handleGetRequest(req) {
		const { connection } = getCurrentAgent();
		if (!connection) throw new Error("Connection was not found in handleGetRequest");
		if (this._eventStore) {
			const lastEventId = req.headers.get("last-event-id");
			if (lastEventId) {
				await this.replayEvents(lastEventId);
				return;
			}
		}
		connection.setState({ _standaloneSse: true });
	}
	/**
	* Replays events that would have been sent after the specified event ID
	* Only used when resumability is enabled
	*/
	async replayEvents(lastEventId) {
		if (!this._eventStore) return;
		const { connection } = getCurrentAgent();
		if (!connection) throw new Error("Connection was not available in replayEvents");
		try {
			await this._eventStore?.replayEventsAfter(lastEventId, { send: async (eventId, message) => {
				try {
					this.writeSSEEvent(connection, message, eventId);
				} catch (error) {
					this.onerror?.(error);
				}
			} });
		} catch (error) {
			this.onerror?.(error);
		}
	}
	/**
	* Writes an event to the SSE stream with proper formatting
	*/
	writeSSEEvent(connection, message, eventId, close) {
		let eventData = "event: message\n";
		if (eventId) eventData += `id: ${eventId}\n`;
		eventData += `data: ${JSON.stringify(message)}\n\n`;
		return connection.send(JSON.stringify({
			type: MessageType.CF_MCP_AGENT_EVENT,
			event: eventData,
			close
		}));
	}
	/**
	* Handles POST requests containing JSON-RPC messages
	*/
	async handlePostRequest(req, parsedBody) {
		const authInfo = req.auth;
		const requestInfo = { headers: Object.fromEntries(req.headers.entries()) };
		delete requestInfo.headers[MCP_HTTP_METHOD_HEADER];
		delete requestInfo.headers[MCP_MESSAGE_HEADER];
		delete requestInfo.headers.upgrade;
		const rawMessage = parsedBody;
		let messages;
		if (Array.isArray(rawMessage)) messages = rawMessage.map((msg) => JSONRPCMessageSchema.parse(msg));
		else messages = [JSONRPCMessageSchema.parse(rawMessage)];
		const hasRequests = messages.some(isJSONRPCRequest);
		if (!hasRequests) for (const message of messages) this.onmessage?.(message, {
			authInfo,
			requestInfo
		});
		else if (hasRequests) {
			const { connection } = getCurrentAgent();
			if (!connection) throw new Error("Connection was not found in handlePostRequest");
			const requestIds = messages.filter(isJSONRPCRequest).map((message) => message.id);
			connection.setState({ requestIds });
			for (const message of messages) this.onmessage?.(message, {
				authInfo,
				requestInfo
			});
		}
	}
	async close() {
		const { agent } = getCurrentAgent();
		if (!agent) throw new Error("Agent was not found in close");
		for (const conn of agent.getConnections()) conn.close(1e3, "Session closed");
		this.onclose?.();
	}
	async send(message, options) {
		const { agent } = getCurrentAgent();
		if (!agent) throw new Error("Agent was not found in send");
		let requestId = options?.relatedRequestId;
		if (isJSONRPCResponse(message) || isJSONRPCError(message)) requestId = message.id;
		if (requestId === void 0) {
			if (isJSONRPCResponse(message) || isJSONRPCError(message)) throw new Error("Cannot send a response on a standalone SSE stream unless resuming a previous client request");
			let standaloneConnection;
			for (const conn of agent.getConnections()) if (conn.state?._standaloneSse) standaloneConnection = conn;
			if (standaloneConnection === void 0) return;
			let eventId$1;
			if (this._eventStore) eventId$1 = await this._eventStore.storeEvent(standaloneConnection.id, message);
			this.writeSSEEvent(standaloneConnection, message, eventId$1);
			return;
		}
		const connection = Array.from(agent.getConnections()).find((conn) => conn.state?.requestIds?.includes(requestId));
		if (!connection) throw new Error(`No connection established for request ID: ${String(requestId)}`);
		let eventId;
		if (this._eventStore) eventId = await this._eventStore.storeEvent(connection.id, message);
		let shouldClose = false;
		if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
			this._requestResponseMap.set(requestId, message);
			const relatedIds = connection.state?.requestIds ?? [];
			shouldClose = relatedIds.every((id) => this._requestResponseMap.has(id));
			if (shouldClose) for (const id of relatedIds) this._requestResponseMap.delete(id);
		}
		this.writeSSEEvent(connection, message, eventId, shouldClose);
	}
};

//#endregion
//#region src/mcp/index.ts
var McpAgent = class McpAgent extends Agent {
	async setInitializeRequest(initializeRequest) {
		await this.ctx.storage.put("initializeRequest", initializeRequest);
	}
	async getInitializeRequest() {
		return this.ctx.storage.get("initializeRequest");
	}
	/** Read the transport type for this agent.
	* This relies on the naming scheme being `sse:${sessionId}`
	* or `streamable-http:${sessionId}`.
	*/
	getTransportType() {
		const [t, ..._] = this.name.split(":");
		switch (t) {
			case "sse": return "sse";
			case "streamable-http": return "streamable-http";
			default: throw new Error("Invalid transport type. McpAgent must be addressed with a valid protocol.");
		}
	}
	/** Read the sessionId for this agent.
	* This relies on the naming scheme being `sse:${sessionId}`
	* or `streamable-http:${sessionId}`.
	*/
	getSessionId() {
		const [_, sessionId] = this.name.split(":");
		if (!sessionId) throw new Error("Invalid session id. McpAgent must be addressed with a valid session id.");
		return sessionId;
	}
	/** Get the unique WebSocket. SSE transport only. */
	getWebSocket() {
		const websockets = Array.from(this.getConnections());
		if (websockets.length === 0) return null;
		return websockets[0];
	}
	/** Returns a new transport matching the type of the Agent. */
	initTransport() {
		switch (this.getTransportType()) {
			case "sse": return new McpSSETransport(() => this.getWebSocket());
			case "streamable-http": return new StreamableHTTPServerTransport({});
		}
	}
	/** Update and store the props */
	async updateProps(props) {
		await this.ctx.storage.put("props", props ?? {});
		this.props = props;
	}
	async reinitializeServer() {
		const initializeRequest = await this.getInitializeRequest();
		if (initializeRequest) this._transport?.onmessage?.(initializeRequest);
	}
	/** Sets up the MCP transport and server every time the Agent is started.*/
	async onStart(props) {
		if (props) await this.updateProps(props);
		this.props = await this.ctx.storage.get("props");
		await this.init();
		const server = await this.server;
		this._transport = this.initTransport();
		await server.connect(this._transport);
		await this.reinitializeServer();
	}
	/** Validates new WebSocket connections. */
	async onConnect(conn, { request: req }) {
		switch (this.getTransportType()) {
			case "sse":
				if (Array.from(this.getConnections()).length > 1) {
					conn.close(1008, "Websocket already connected");
					return;
				}
				break;
			case "streamable-http": if (this._transport instanceof StreamableHTTPServerTransport) switch (req.headers.get(MCP_HTTP_METHOD_HEADER)) {
				case "POST": {
					const payloadHeader = req.headers.get(MCP_MESSAGE_HEADER);
					let rawPayload;
					if (!payloadHeader) rawPayload = "{}";
					else try {
						rawPayload = Buffer.from(payloadHeader, "base64").toString("utf-8");
					} catch (_error) {
						throw new Error("Internal Server Error: Failed to decode MCP message header");
					}
					const parsedBody = JSON.parse(rawPayload);
					this._transport?.handlePostRequest(req, parsedBody);
					break;
				}
				case "GET":
					this._transport?.handleGetRequest(req);
					break;
			}
		}
	}
	/** Handles MCP Messages for the legacy SSE transport. */
	async onSSEMcpMessage(_sessionId, messageBody) {
		if (this.getTransportType() !== "sse") return /* @__PURE__ */ new Error("Internal Server Error: Expected SSE transport");
		try {
			let parsedMessage;
			try {
				parsedMessage = JSONRPCMessageSchema.parse(messageBody);
			} catch (error) {
				this._transport?.onerror?.(error);
				throw error;
			}
			if (await this._handleElicitationResponse(parsedMessage)) return null;
			this._transport?.onmessage?.(parsedMessage);
			return null;
		} catch (error) {
			console.error("Error forwarding message to SSE:", error);
			this._transport?.onerror?.(error);
			return error;
		}
	}
	/** Elicit user input with a message and schema */
	async elicitInput(params) {
		const requestId = `elicit_${Math.random().toString(36).substring(2, 11)}`;
		await this.ctx.storage.put(`elicitation:${requestId}`, {
			message: params.message,
			requestedSchema: params.requestedSchema,
			timestamp: Date.now()
		});
		const elicitRequest = {
			jsonrpc: "2.0",
			id: requestId,
			method: "elicitation/create",
			params: {
				message: params.message,
				requestedSchema: params.requestedSchema
			}
		};
		if (this._transport) await this._transport.send(elicitRequest);
		else {
			const connections = this.getConnections();
			if (!connections || Array.from(connections).length === 0) {
				await this.ctx.storage.delete(`elicitation:${requestId}`);
				throw new Error("No active connections available for elicitation");
			}
			const connectionList = Array.from(connections);
			for (const connection of connectionList) try {
				connection.send(JSON.stringify(elicitRequest));
			} catch (error) {
				console.error("Failed to send elicitation request:", error);
			}
		}
		return this._waitForElicitationResponse(requestId);
	}
	/** Wait for elicitation response through storage polling */
	async _waitForElicitationResponse(requestId) {
		const startTime = Date.now();
		const timeout = 6e4;
		try {
			while (Date.now() - startTime < timeout) {
				const response = await this.ctx.storage.get(`elicitation:response:${requestId}`);
				if (response) {
					await this.ctx.storage.delete(`elicitation:${requestId}`);
					await this.ctx.storage.delete(`elicitation:response:${requestId}`);
					return response;
				}
				await new Promise((resolve) => setTimeout(resolve, 100));
			}
			throw new Error("Elicitation request timed out");
		} finally {
			await this.ctx.storage.delete(`elicitation:${requestId}`);
			await this.ctx.storage.delete(`elicitation:response:${requestId}`);
		}
	}
	/** Handle elicitation responses */
	async _handleElicitationResponse(message) {
		if (isJSONRPCResponse(message) && message.result) {
			const requestId = message.id?.toString();
			if (!requestId || !requestId.startsWith("elicit_")) return false;
			if (!await this.ctx.storage.get(`elicitation:${requestId}`)) return false;
			await this.ctx.storage.put(`elicitation:response:${requestId}`, message.result);
			return true;
		}
		if (isJSONRPCError(message)) {
			const requestId = message.id?.toString();
			if (!requestId || !requestId.startsWith("elicit_")) return false;
			if (!await this.ctx.storage.get(`elicitation:${requestId}`)) return false;
			const errorResult = {
				action: "cancel",
				content: { error: message.error.message || "Elicitation request failed" }
			};
			await this.ctx.storage.put(`elicitation:response:${requestId}`, errorResult);
			return true;
		}
		return false;
	}
	/** Return a handler for the given path for this MCP.
	* Defaults to Streamable HTTP transport.
	*/
	static serve(path, { binding = "MCP_OBJECT", corsOptions, transport = "streamable-http" } = {}) {
		return { async fetch(request, env, ctx) {
			const corsResponse = handleCORS(request, corsOptions);
			if (corsResponse) return corsResponse;
			const bindingValue = env[binding];
			if (bindingValue == null || typeof bindingValue !== "object") throw new Error(`Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`);
			if (!isDurableObjectNamespace(bindingValue)) throw new Error(`Invalid McpAgent binding for ${binding}. Make sure it's a Durable Object binding.`);
			const namespace = bindingValue;
			switch (transport) {
				case "streamable-http": return createStreamingHttpHandler(path, namespace, corsOptions)(request, ctx);
				case "sse": return createLegacySseHandler(path, namespace, corsOptions)(request, ctx);
				default: return new Response("Invalid MCP transport mode. Only `streamable-http` or `sse` are allowed.", { status: 500 });
			}
		} };
	}
	/**
	* Legacy api
	**/
	static mount(path, opts = {}) {
		return McpAgent.serveSSE(path, opts);
	}
	static serveSSE(path, opts = {}) {
		return McpAgent.serve(path, {
			...opts,
			transport: "sse"
		});
	}
};

//#endregion
export { ElicitRequestSchema, McpAgent, SSEEdgeClientTransport, StreamableHTTPEdgeClientTransport };
//# sourceMappingURL=index.js.map