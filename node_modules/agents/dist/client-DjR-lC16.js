import { MessageType } from "./ai-types-UZlfLOYP.js";
import { PartySocket } from "partysocket";

//#region src/client.ts
/**
* Convert a camelCase string to a kebab-case string
* @param str The string to convert
* @returns The kebab-case string
*/
function camelCaseToKebabCase(str) {
	if (str === str.toUpperCase() && str !== str.toLowerCase()) return str.toLowerCase().replace(/_/g, "-");
	let kebabified = str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
	kebabified = kebabified.startsWith("-") ? kebabified.slice(1) : kebabified;
	return kebabified.replace(/_/g, "-").replace(/-$/, "");
}
/**
* WebSocket client for connecting to an Agent
*/
var AgentClient = class extends PartySocket {
	/**
	* @deprecated Use agentFetch instead
	*/
	static fetch(_opts) {
		throw new Error("AgentClient.fetch is not implemented, use agentFetch instead");
	}
	constructor(options) {
		const agentNamespace = camelCaseToKebabCase(options.agent);
		super({
			party: agentNamespace,
			prefix: "agents",
			room: options.name || "default",
			...options
		});
		this._pendingCalls = /* @__PURE__ */ new Map();
		this.agent = agentNamespace;
		this.name = options.name || "default";
		this.options = options;
		this.addEventListener("message", (event) => {
			if (typeof event.data === "string") {
				let parsedMessage;
				try {
					parsedMessage = JSON.parse(event.data);
				} catch (_error) {
					return;
				}
				if (parsedMessage.type === MessageType.CF_AGENT_STATE) {
					this.options.onStateUpdate?.(parsedMessage.state, "server");
					return;
				}
				if (parsedMessage.type === MessageType.RPC) {
					const response = parsedMessage;
					const pending = this._pendingCalls.get(response.id);
					if (!pending) return;
					if (!response.success) {
						pending.reject(new Error(response.error));
						this._pendingCalls.delete(response.id);
						pending.stream?.onError?.(response.error);
						return;
					}
					if ("done" in response) if (response.done) {
						pending.resolve(response.result);
						this._pendingCalls.delete(response.id);
						pending.stream?.onDone?.(response.result);
					} else pending.stream?.onChunk?.(response.result);
					else {
						pending.resolve(response.result);
						this._pendingCalls.delete(response.id);
					}
				}
			}
		});
	}
	setState(state) {
		this.send(JSON.stringify({
			state,
			type: MessageType.CF_AGENT_STATE
		}));
		this.options.onStateUpdate?.(state, "client");
	}
	async call(method, args = [], streamOptions) {
		return new Promise((resolve, reject) => {
			const id = Math.random().toString(36).slice(2);
			this._pendingCalls.set(id, {
				reject,
				resolve: (value) => resolve(value),
				stream: streamOptions,
				type: null
			});
			const request = {
				args,
				id,
				method,
				type: MessageType.RPC
			};
			this.send(JSON.stringify(request));
		});
	}
};
/**
* Make an HTTP request to an Agent
* @param opts Connection options
* @param init Request initialization options
* @returns Promise resolving to a Response
*/
function agentFetch(opts, init) {
	const agentNamespace = camelCaseToKebabCase(opts.agent);
	return PartySocket.fetch({
		party: agentNamespace,
		prefix: "agents",
		room: opts.name || "default",
		...opts
	}, init);
}

//#endregion
export { AgentClient, agentFetch, camelCaseToKebabCase };
//# sourceMappingURL=client-DjR-lC16.js.map