{"version":3,"file":"index.js","names":["body","rawMessage: unknown","arrayMessage: unknown[]","messages: JSONRPCMessage[]","existingHeaders: Record<string, string>","event","authInfo: AuthInfo | undefined","requestInfo: RequestInfo","messages: JSONRPCMessage[]","standaloneConnection: Connection | undefined","eventId: string | undefined","eventId","rawPayload: string","parsedMessage: JSONRPCMessage","errorResult: ElicitResult"],"sources":["../../src/mcp/utils.ts","../../src/mcp/transport.ts","../../src/mcp/index.ts"],"sourcesContent":["import {\n  JSONRPCMessageSchema,\n  type JSONRPCMessage,\n  InitializeRequestSchema,\n  isJSONRPCResponse,\n  isJSONRPCNotification\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { McpAgent } from \".\";\nimport { getAgentByName } from \"..\";\nimport type { CORSOptions } from \"./types\";\nimport { MessageType } from \"../ai-types\";\n\n/**\n * Since we use WebSockets to bridge the client to the\n * MCP transport in the Agent, we use this header to signal\n * the method of the original request the user made, while\n * leaving the WS Upgrade request as GET.\n */\nexport const MCP_HTTP_METHOD_HEADER = \"cf-mcp-method\";\n\n/**\n * Since we use WebSockets to bridge the client to the\n * MCP transport in the Agent, we use this header to include\n * the original request body.\n */\nexport const MCP_MESSAGE_HEADER = \"cf-mcp-message\";\n\nconst MAXIMUM_MESSAGE_SIZE_BYTES = 4 * 1024 * 1024; // 4MB\n\nexport const createStreamingHttpHandler = (\n  basePath: string,\n  namespace: DurableObjectNamespace<McpAgent>,\n  corsOptions?: CORSOptions\n) => {\n  let pathname = basePath;\n  if (basePath === \"/\") pathname = \"/*\";\n\n  const basePattern = new URLPattern({ pathname });\n  return async (request: Request, ctx: ExecutionContext) => {\n    const url = new URL(request.url);\n    if (basePattern.test(url)) {\n      if (request.method === \"POST\") {\n        // Validate the Accept header\n        const acceptHeader = request.headers.get(\"accept\");\n        // The client MUST include an Accept header, listing both application/json and text/event-stream as supported content types.\n        if (\n          !acceptHeader?.includes(\"application/json\") ||\n          !acceptHeader.includes(\"text/event-stream\")\n        ) {\n          const body = JSON.stringify({\n            error: {\n              code: -32000,\n              message:\n                \"Not Acceptable: Client must accept both application/json and text/event-stream\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 406 });\n        }\n\n        const ct = request.headers.get(\"content-type\");\n        if (!ct || !ct.includes(\"application/json\")) {\n          const body = JSON.stringify({\n            error: {\n              code: -32000,\n              message:\n                \"Unsupported Media Type: Content-Type must be application/json\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 415 });\n        }\n\n        // Check content length against maximum allowed size\n        const contentLength = Number.parseInt(\n          request.headers.get(\"content-length\") ?? \"0\",\n          10\n        );\n        if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {\n          const body = JSON.stringify({\n            error: {\n              code: -32000,\n              message: `Request body too large. Maximum size is ${MAXIMUM_MESSAGE_SIZE_BYTES} bytes`\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 413 });\n        }\n\n        let sessionId = request.headers.get(\"mcp-session-id\");\n        let rawMessage: unknown;\n\n        try {\n          rawMessage = await request.json();\n        } catch (_error) {\n          const body = JSON.stringify({\n            error: {\n              code: -32700,\n              message: \"Parse error: Invalid JSON\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 400 });\n        }\n\n        // Make sure the message is an array to simplify logic\n        let arrayMessage: unknown[];\n        if (Array.isArray(rawMessage)) {\n          arrayMessage = rawMessage;\n        } else {\n          arrayMessage = [rawMessage];\n        }\n\n        let messages: JSONRPCMessage[] = [];\n\n        // Try to parse each message as JSON RPC. Fail if any message is invalid\n        for (const msg of arrayMessage) {\n          if (!JSONRPCMessageSchema.safeParse(msg).success) {\n            const body = JSON.stringify({\n              error: {\n                code: -32700,\n                message: \"Parse error: Invalid JSON-RPC message\"\n              },\n              id: null,\n              jsonrpc: \"2.0\"\n            });\n            return new Response(body, { status: 400 });\n          }\n        }\n\n        messages = arrayMessage.map((msg) => JSONRPCMessageSchema.parse(msg));\n\n        // Before we pass the messages to the agent, there's another error condition we need to enforce\n        // Check if this is an initialization request\n        // https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/lifecycle/\n        const maybeInitializeRequest = messages.find(\n          (msg) => InitializeRequestSchema.safeParse(msg).success\n        );\n\n        if (!!maybeInitializeRequest && sessionId) {\n          const body = JSON.stringify({\n            error: {\n              code: -32600,\n              message:\n                \"Invalid Request: Initialization requests must not include a sessionId\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 400 });\n        }\n\n        // The initialization request must be the only request in the batch\n        if (!!maybeInitializeRequest && messages.length > 1) {\n          const body = JSON.stringify({\n            error: {\n              code: -32600,\n              message:\n                \"Invalid Request: Only one initialization request is allowed\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 400 });\n        }\n\n        // If an Mcp-Session-Id is returned by the server during initialization,\n        // clients using the Streamable HTTP transport MUST include it\n        // in the Mcp-Session-Id header on all of their subsequent HTTP requests.\n        if (!maybeInitializeRequest && !sessionId) {\n          const body = JSON.stringify({\n            error: {\n              code: -32000,\n              message: \"Bad Request: Mcp-Session-Id header is required\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 400 });\n        }\n\n        // If we don't have a sessionId, we are serving an initialization request\n        // and need to generate a new sessionId\n        sessionId = sessionId ?? namespace.newUniqueId().toString();\n\n        // Get the agent and set props\n        const agent = await getAgentByName(\n          namespace,\n          `streamable-http:${sessionId}`,\n          { props: ctx.props as Record<string, unknown> | undefined }\n        );\n        const isInitialized = await agent.getInitializeRequest();\n\n        if (maybeInitializeRequest) {\n          await agent.setInitializeRequest(maybeInitializeRequest);\n        } else if (!isInitialized) {\n          // if we have gotten here, then a session id that was never initialized\n          // was provided\n          const body = JSON.stringify({\n            error: {\n              code: -32001,\n              message: \"Session not found\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 404 });\n        }\n\n        // We've evaluated all the error conditions! Now it's time to establish\n        // all the streams\n\n        // Create a Transform Stream for SSE\n        const { readable, writable } = new TransformStream();\n        const writer = writable.getWriter();\n        const encoder = new TextEncoder();\n\n        // Connect to the Durable Object via WebSocket\n        const existingHeaders: Record<string, string> = {};\n        request.headers.forEach((value, key) => {\n          existingHeaders[key] = value;\n        });\n\n        const req = new Request(request.url, {\n          headers: {\n            ...existingHeaders,\n            [MCP_HTTP_METHOD_HEADER]: \"POST\",\n            [MCP_MESSAGE_HEADER]: Buffer.from(\n              JSON.stringify(messages)\n            ).toString(\"base64\"),\n            Upgrade: \"websocket\"\n          }\n        });\n        if (ctx.props) agent.updateProps(ctx.props as Record<string, unknown>);\n        const response = await agent.fetch(req);\n\n        // Get the WebSocket\n        const ws = response.webSocket;\n        if (!ws) {\n          console.error(\"Failed to establish WebSocket connection\");\n\n          await writer.close();\n          const body = JSON.stringify({\n            error: {\n              code: -32001,\n              message: \"Failed to establish WebSocket connection\"\n            },\n            id: null,\n            jsonrpc: \"2.0\"\n          });\n          return new Response(body, { status: 500 });\n        }\n\n        // Accept the WebSocket\n        ws.accept();\n\n        // Handle messages from the Durable Object\n        ws.addEventListener(\"message\", (event) => {\n          async function onMessage(event: MessageEvent) {\n            try {\n              const data =\n                typeof event.data === \"string\"\n                  ? event.data\n                  : new TextDecoder().decode(event.data);\n              const message = JSON.parse(data);\n\n              // We only forward events from the MCP server\n              if (message.type !== MessageType.CF_MCP_AGENT_EVENT) {\n                return;\n              }\n\n              // Send the message as an SSE event\n              await writer.write(encoder.encode(message.event));\n\n              // If we have received all the responses, close the connection\n              if (message.close) {\n                ws?.close();\n                await writer.close().catch(() => {});\n              }\n            } catch (error) {\n              console.error(\"Error forwarding message to SSE:\", error);\n            }\n          }\n          onMessage(event).catch(console.error);\n        });\n\n        // Handle WebSocket errors\n        ws.addEventListener(\"error\", (error) => {\n          async function onError(_error: Event) {\n            await writer.close().catch(() => {});\n          }\n          onError(error).catch(console.error);\n        });\n\n        // Handle WebSocket closure\n        ws.addEventListener(\"close\", () => {\n          async function onClose() {\n            await writer.close().catch(() => {});\n          }\n          onClose().catch(console.error);\n        });\n\n        // If there are no requests, we send the messages to the agent and acknowledge the request with a 202\n        // since we don't expect any responses back through this connection\n        const hasOnlyNotificationsOrResponses = messages.every(\n          (msg) => isJSONRPCNotification(msg) || isJSONRPCResponse(msg)\n        );\n        if (hasOnlyNotificationsOrResponses) {\n          // closing the websocket will also close the SSE connection\n          ws.close();\n\n          return new Response(null, {\n            headers: corsHeaders(request, corsOptions),\n            status: 202\n          });\n        }\n\n        // Return the SSE response. We handle closing the stream in the ws \"message\"\n        // handler\n        return new Response(readable, {\n          headers: {\n            \"Cache-Control\": \"no-cache\",\n            Connection: \"keep-alive\",\n            \"Content-Type\": \"text/event-stream\",\n            \"mcp-session-id\": sessionId,\n            ...corsHeaders(request, corsOptions)\n          },\n          status: 200\n        });\n      } else if (request.method === \"GET\") {\n        // Validate the Accept header\n        const acceptHeader = request.headers.get(\"accept\");\n        // The client MUST include an Accept header, listing both application/json and text/event-stream as supported content types.\n        if (!acceptHeader?.includes(\"text/event-stream\")) {\n          const body = JSON.stringify({\n            jsonrpc: \"2.0\",\n            error: {\n              code: -32000,\n              message: \"Not Acceptable: Client must accept text/event-stream\"\n            },\n            id: null\n          });\n          return new Response(body, { status: 406 });\n        }\n\n        // Require sessionId\n        const sessionId = request.headers.get(\"mcp-session-id\");\n        if (!sessionId)\n          return new Response(\n            JSON.stringify({\n              error: {\n                code: -32000,\n                message: \"Bad Request: Mcp-Session-Id header is required\"\n              },\n              id: null,\n              jsonrpc: \"2.0\"\n            }),\n            { status: 400 }\n          );\n\n        // Create SSE stream\n        const { readable, writable } = new TransformStream();\n        const writer = writable.getWriter();\n        const encoder = new TextEncoder();\n\n        const agent = await getAgentByName(\n          namespace,\n          `streamable-http:${sessionId}`,\n          { props: ctx.props as Record<string, unknown> | undefined }\n        );\n        const isInitialized = await agent.getInitializeRequest();\n        if (!isInitialized) {\n          return new Response(\n            JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: { code: -32001, message: \"Session not found\" },\n              id: null\n            }),\n            { status: 404 }\n          );\n        }\n\n        const existingHeaders: Record<string, string> = {};\n        request.headers.forEach((v, k) => {\n          existingHeaders[k] = v;\n        });\n\n        if (ctx.props) agent.updateProps(ctx.props as Record<string, unknown>);\n        const response = await agent.fetch(\n          new Request(request.url, {\n            headers: {\n              ...existingHeaders,\n              [MCP_HTTP_METHOD_HEADER]: \"GET\",\n              Upgrade: \"websocket\"\n            }\n          })\n        );\n\n        const ws = response.webSocket;\n        if (!ws) {\n          await writer.close();\n          return new Response(\"Failed to establish WS to DO\", {\n            status: 500\n          });\n        }\n        ws.accept();\n\n        // Forward DO messages as SSE\n        ws.addEventListener(\"message\", (event) => {\n          try {\n            async function onMessage(ev: MessageEvent) {\n              const data =\n                typeof ev.data === \"string\"\n                  ? ev.data\n                  : new TextDecoder().decode(ev.data);\n              const message = JSON.parse(data);\n\n              // We only forward events from the MCP server\n              if (message.type !== MessageType.CF_MCP_AGENT_EVENT) {\n                return;\n              }\n              await writer.write(encoder.encode(message.event));\n            }\n            onMessage(event).catch(console.error);\n          } catch (e) {\n            console.error(\"Error forwarding message to SSE:\", e);\n          }\n        });\n\n        ws.addEventListener(\"error\", () => {\n          writer.close().catch(() => {});\n        });\n        ws.addEventListener(\"close\", () => {\n          writer.close().catch(() => {});\n        });\n\n        return new Response(readable, {\n          headers: {\n            \"Cache-Control\": \"no-cache\",\n            Connection: \"keep-alive\",\n            \"Content-Type\": \"text/event-stream\",\n            \"mcp-session-id\": sessionId,\n            ...corsHeaders(request, corsOptions)\n          },\n          status: 200\n        });\n      } else if (request.method === \"DELETE\") {\n        const sessionId = request.headers.get(\"mcp-session-id\");\n        if (!sessionId) {\n          return new Response(\n            JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message: \"Bad Request: Mcp-Session-Id header is required\"\n              },\n              id: null\n            }),\n            { status: 400, headers: corsHeaders(request, corsOptions) }\n          );\n        }\n        const agent = await getAgentByName(\n          namespace,\n          `streamable-http:${sessionId}`\n        );\n        const isInitialized = await agent.getInitializeRequest();\n        if (!isInitialized) {\n          return new Response(\n            JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: { code: -32001, message: \"Session not found\" },\n              id: null\n            }),\n            { status: 404, headers: corsHeaders(request, corsOptions) }\n          );\n        }\n        // .destroy() passes an uncatchable Error, so we make sure we first return\n        // the response to the client.\n        ctx.waitUntil(\n          agent.destroy().catch(() => {\n            /* This will always throw. We silently catch here */\n          })\n        );\n        return new Response(null, {\n          status: 204,\n          headers: corsHeaders(request, corsOptions)\n        });\n      }\n    }\n\n    // Route not found\n    const body = JSON.stringify({\n      error: {\n        code: -32000,\n        message: \"Not found\"\n      },\n      id: null,\n      jsonrpc: \"2.0\"\n    });\n    return new Response(body, { status: 404 });\n  };\n};\n\nexport const createLegacySseHandler = (\n  basePath: string,\n  namespace: DurableObjectNamespace<McpAgent>,\n  corsOptions?: CORSOptions\n) => {\n  let pathname = basePath;\n  if (basePath === \"/\") pathname = \"/*\";\n\n  const basePattern = new URLPattern({ pathname });\n  const messagePattern = new URLPattern({ pathname: `${basePath}/message` }); // SSE only\n  return async (request: Request, ctx: ExecutionContext) => {\n    const url = new URL(request.url);\n    // Handle initial SSE connection\n    if (request.method === \"GET\" && basePattern.test(url)) {\n      // Use a session ID if one is passed in, or create a unique\n      // session ID for this connection\n      const sessionId =\n        url.searchParams.get(\"sessionId\") || namespace.newUniqueId().toString();\n\n      // Create a Transform Stream for SSE\n      const { readable, writable } = new TransformStream();\n      const writer = writable.getWriter();\n      const encoder = new TextEncoder();\n\n      // Send the endpoint event\n      const endpointUrl = new URL(request.url);\n      endpointUrl.pathname = encodeURI(`${basePath}/message`);\n      endpointUrl.searchParams.set(\"sessionId\", sessionId);\n      const relativeUrlWithSession =\n        endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;\n      const endpointMessage = `event: endpoint\\ndata: ${relativeUrlWithSession}\\n\\n`;\n      writer.write(encoder.encode(endpointMessage));\n\n      // Get the Durable Object\n      const agent = await getAgentByName(namespace, `sse:${sessionId}`, {\n        props: ctx.props as Record<string, unknown> | undefined\n      });\n\n      // Connect to the Durable Object via WebSocket\n      const existingHeaders: Record<string, string> = {};\n      request.headers.forEach((value, key) => {\n        existingHeaders[key] = value;\n      });\n      if (ctx.props) agent.updateProps(ctx.props as Record<string, unknown>);\n      const response = await agent.fetch(\n        new Request(request.url, {\n          headers: {\n            ...existingHeaders,\n            Upgrade: \"websocket\"\n          }\n        })\n      );\n\n      // Get the WebSocket\n      const ws = response.webSocket;\n      if (!ws) {\n        console.error(\"Failed to establish WebSocket connection\");\n        await writer.close();\n        return new Response(\"Failed to establish WebSocket connection\", {\n          status: 500\n        });\n      }\n\n      // Accept the WebSocket\n      ws.accept();\n\n      // Handle messages from the Durable Object\n      ws.addEventListener(\"message\", (event) => {\n        async function onMessage(event: MessageEvent) {\n          try {\n            const message = JSON.parse(event.data);\n\n            // validate that the message is a valid JSONRPC message\n            const result = JSONRPCMessageSchema.safeParse(message);\n            if (!result.success) {\n              // The message was not a valid JSONRPC message, so we will drop it\n              // PartyKit will broadcast state change messages to all connected clients\n              // and we need to filter those out so they are not passed to MCP clients\n              return;\n            }\n\n            // Send the message as an SSE event\n            const messageText = `event: message\\ndata: ${JSON.stringify(result.data)}\\n\\n`;\n            await writer.write(encoder.encode(messageText));\n          } catch (error) {\n            console.error(\"Error forwarding message to SSE:\", error);\n          }\n        }\n        onMessage(event).catch(console.error);\n      });\n\n      // Handle WebSocket errors\n      ws.addEventListener(\"error\", (error) => {\n        async function onError(_error: Event) {\n          try {\n            await writer.close();\n          } catch (_e) {\n            // Ignore errors when closing\n          }\n        }\n        onError(error).catch(console.error);\n      });\n\n      // Handle WebSocket closure\n      ws.addEventListener(\"close\", () => {\n        async function onClose() {\n          try {\n            await writer.close();\n          } catch (error) {\n            console.error(\"Error closing SSE connection:\", error);\n          }\n        }\n        onClose().catch(console.error);\n      });\n\n      // Return the SSE response\n      return new Response(readable, {\n        headers: {\n          \"Cache-Control\": \"no-cache\",\n          Connection: \"keep-alive\",\n          \"Content-Type\": \"text/event-stream\",\n          ...corsHeaders(request, corsOptions)\n        }\n      });\n    }\n\n    // Handle incoming MCP messages. These will be passed to McpAgent\n    // but the response will be sent back via the open SSE connection\n    // so we only need to return a 202 Accepted response for success\n    if (request.method === \"POST\" && messagePattern.test(url)) {\n      const sessionId = url.searchParams.get(\"sessionId\");\n      if (!sessionId) {\n        return new Response(\n          `Missing sessionId. Expected POST to ${basePath} to initiate new one`,\n          { status: 400 }\n        );\n      }\n\n      const contentType = request.headers.get(\"content-type\") || \"\";\n      if (!contentType.includes(\"application/json\")) {\n        return new Response(`Unsupported content-type: ${contentType}`, {\n          status: 400\n        });\n      }\n\n      // check if the request body is too large\n      const contentLength = Number.parseInt(\n        request.headers.get(\"content-length\") || \"0\",\n        10\n      );\n      if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {\n        return new Response(`Request body too large: ${contentLength} bytes`, {\n          status: 400\n        });\n      }\n\n      // Get the Durable Object\n      const agent = await getAgentByName(namespace, `sse:${sessionId}`, {\n        props: ctx.props as Record<string, unknown> | undefined\n      });\n\n      const messageBody = await request.json();\n      const error = await agent.onSSEMcpMessage(sessionId, messageBody);\n\n      if (error) {\n        return new Response(error.message, {\n          headers: {\n            \"Cache-Control\": \"no-cache\",\n            Connection: \"keep-alive\",\n            \"Content-Type\": \"text/event-stream\",\n            ...corsHeaders(request, corsOptions)\n          },\n          status: 400\n        });\n      }\n\n      return new Response(\"Accepted\", {\n        headers: {\n          \"Cache-Control\": \"no-cache\",\n          Connection: \"keep-alive\",\n          \"Content-Type\": \"text/event-stream\",\n          ...corsHeaders(request, corsOptions)\n        },\n        status: 202\n      });\n    }\n\n    return new Response(\"Not Found\", { status: 404 });\n  };\n};\n\n// CORS helper functions\nfunction corsHeaders(_request: Request, corsOptions: CORSOptions = {}) {\n  const origin = \"*\";\n  return {\n    \"Access-Control-Allow-Headers\":\n      corsOptions.headers ||\n      \"Content-Type, Accept, mcp-session-id, mcp-protocol-version\",\n    \"Access-Control-Allow-Methods\":\n      corsOptions.methods || \"GET, POST, DELETE, OPTIONS\",\n    \"Access-Control-Allow-Origin\": corsOptions.origin || origin,\n    \"Access-Control-Expose-Headers\":\n      corsOptions.exposeHeaders || \"mcp-session-id\",\n    \"Access-Control-Max-Age\": (corsOptions.maxAge || 86400).toString()\n  };\n}\n\nexport function handleCORS(\n  request: Request,\n  corsOptions?: CORSOptions\n): Response | null {\n  if (request.method === \"OPTIONS\") {\n    return new Response(null, { headers: corsHeaders(request, corsOptions) });\n  }\n\n  return null;\n}\n\nexport function isDurableObjectNamespace(\n  namespace: unknown\n): namespace is DurableObjectNamespace<McpAgent> {\n  return (\n    typeof namespace === \"object\" &&\n    namespace !== null &&\n    \"newUniqueId\" in namespace &&\n    typeof namespace.newUniqueId === \"function\" &&\n    \"idFromName\" in namespace &&\n    typeof namespace.idFromName === \"function\"\n  );\n}\n","import type { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport {\n  type MessageExtraInfo,\n  type RequestInfo,\n  isJSONRPCError,\n  isJSONRPCRequest,\n  isJSONRPCResponse,\n  type JSONRPCMessage,\n  JSONRPCMessageSchema,\n  type RequestId\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { AuthInfo } from \"@modelcontextprotocol/sdk/server/auth/types.js\";\nimport { getCurrentAgent, type Connection } from \"..\";\nimport type { McpAgent } from \".\";\nimport { MessageType } from \"../ai-types\";\nimport { MCP_HTTP_METHOD_HEADER, MCP_MESSAGE_HEADER } from \"./utils\";\n\nexport class McpSSETransport implements Transport {\n  sessionId?: string;\n  // Set by the server in `server.connect(transport)`\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  private _getWebSocket: () => WebSocket | null;\n  private _started = false;\n  constructor(getWebSocket: () => WebSocket | null) {\n    this._getWebSocket = getWebSocket;\n  }\n\n  async start() {\n    // The transport does not manage the WebSocket connection since it's terminated\n    // by the Durable Object in order to allow hibernation. There's nothing to initialize.\n    if (this._started) {\n      throw new Error(\"Transport already started\");\n    }\n    this._started = true;\n  }\n\n  async send(message: JSONRPCMessage) {\n    if (!this._started) {\n      throw new Error(\"Transport not started\");\n    }\n    const websocket = this._getWebSocket();\n    if (!websocket) {\n      throw new Error(\"WebSocket not connected\");\n    }\n    try {\n      websocket.send(JSON.stringify(message));\n    } catch (error) {\n      this.onerror?.(error as Error);\n    }\n  }\n\n  async close() {\n    // Similar to start, the only thing to do is to pass the event on to the server\n    this.onclose?.();\n  }\n}\n\nexport type StreamId = string;\nexport type EventId = string;\n\n// TODO: Implement this and make it opt-in?\n/**\n * Interface for resumability support via event storage\n */\nexport interface EventStore {\n  /**\n   * Stores an event for later retrieval\n   * @param streamId ID of the stream the event belongs to\n   * @param message The JSON-RPC message to store\n   * @returns The generated event ID for the stored event\n   */\n  storeEvent(streamId: StreamId, message: JSONRPCMessage): Promise<EventId>;\n\n  replayEventsAfter(\n    lastEventId: EventId,\n    {\n      send\n    }: {\n      send: (eventId: EventId, message: JSONRPCMessage) => Promise<void>;\n    }\n  ): Promise<StreamId>;\n}\n\n/**\n * Configuration options for StreamableHTTPServerTransport\n */\nexport interface StreamableHTTPServerTransportOptions {\n  /**\n   * Event store for resumability support\n   * If provided, resumability will be enabled, allowing clients to reconnect and resume messages\n   */\n  eventStore?: EventStore;\n}\n\n/**\n * Adapted from: https://github.com/modelcontextprotocol/typescript-sdk/blob/main/src/client/streamableHttp.ts\n * - Validation and initialization are removed as they're handled in `McpAgent.serve()` handler.\n * - Replaces the Node-style `req`/`res` with Worker's `Request`.\n * - Writes events as WS messages that the Worker forwards to the client as SSE events.\n * - Replaces the in-memory maps that track requestID/stream by using `connection.setState()` and `agent.getConnections()`.\n *\n * Besides these points, the implementation is the same and should be updated to match the original as new features are added.\n */\nexport class StreamableHTTPServerTransport implements Transport {\n  private _started = false;\n  private _eventStore?: EventStore;\n\n  // This is to keep track whether all messages from a single POST request have been answered.\n  // I's fine that we don't persist this since it's only for backwards compatibility as clients\n  // should no longer batch requests, per the spec.\n  private _requestResponseMap: Map<RequestId, JSONRPCMessage> = new Map();\n\n  sessionId: string;\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage, extra?: MessageExtraInfo) => void;\n\n  constructor(options: StreamableHTTPServerTransportOptions) {\n    const { agent } = getCurrentAgent<McpAgent>();\n    if (!agent)\n      throw new Error(\"McpAgent was not found in Transport constructor\");\n\n    // Initialization is handled in `McpAgent.serve()` and agents are addressed by sessionId,\n    // so we'll always have this available.\n    this.sessionId = agent.getSessionId();\n    this._eventStore = options.eventStore;\n  }\n\n  /**\n   * Starts the transport. This is required by the Transport interface but is a no-op\n   * for the Streamable HTTP transport as connections are managed per-request.\n   */\n  async start(): Promise<void> {\n    if (this._started) {\n      throw new Error(\"Transport already started\");\n    }\n    this._started = true;\n  }\n\n  /**\n   * Handles GET requests for SSE stream\n   */\n  async handleGetRequest(req: Request): Promise<void> {\n    // Get the WS connection so we can tag it as the standalone stream\n    const { connection } = getCurrentAgent();\n    if (!connection)\n      throw new Error(\"Connection was not found in handleGetRequest\");\n\n    // Handle resumability: check for Last-Event-ID header\n    if (this._eventStore) {\n      const lastEventId = req.headers.get(\"last-event-id\");\n      if (lastEventId) {\n        await this.replayEvents(lastEventId);\n        return;\n      }\n    }\n\n    connection.setState({\n      _standaloneSse: true\n    });\n  }\n\n  /**\n   * Replays events that would have been sent after the specified event ID\n   * Only used when resumability is enabled\n   */\n  private async replayEvents(lastEventId: string): Promise<void> {\n    if (!this._eventStore) {\n      return;\n    }\n\n    const { connection } = getCurrentAgent();\n    if (!connection)\n      throw new Error(\"Connection was not available in replayEvents\");\n\n    try {\n      await this._eventStore?.replayEventsAfter(lastEventId, {\n        send: async (eventId: string, message: JSONRPCMessage) => {\n          try {\n            this.writeSSEEvent(connection, message, eventId);\n          } catch (error) {\n            this.onerror?.(error as Error);\n          }\n        }\n      });\n    } catch (error) {\n      this.onerror?.(error as Error);\n    }\n  }\n\n  /**\n   * Writes an event to the SSE stream with proper formatting\n   */\n  private writeSSEEvent(\n    connection: Connection,\n    message: JSONRPCMessage,\n    eventId?: string,\n    close?: boolean\n  ) {\n    let eventData = \"event: message\\n\";\n    // Include event ID if provided - this is important for resumability\n    if (eventId) {\n      eventData += `id: ${eventId}\\n`;\n    }\n    eventData += `data: ${JSON.stringify(message)}\\n\\n`;\n\n    return connection.send(\n      JSON.stringify({\n        type: MessageType.CF_MCP_AGENT_EVENT,\n        event: eventData,\n        close\n      })\n    );\n  }\n\n  /**\n   * Handles POST requests containing JSON-RPC messages\n   */\n  async handlePostRequest(\n    req: Request & { auth?: AuthInfo },\n    parsedBody: unknown\n  ): Promise<void> {\n    const authInfo: AuthInfo | undefined = req.auth;\n    const requestInfo: RequestInfo = {\n      headers: Object.fromEntries(req.headers.entries())\n    };\n    // Remove headers that are not part of the original request\n    delete requestInfo.headers[MCP_HTTP_METHOD_HEADER];\n    delete requestInfo.headers[MCP_MESSAGE_HEADER];\n    delete requestInfo.headers.upgrade;\n\n    const rawMessage = parsedBody;\n    let messages: JSONRPCMessage[];\n\n    // handle batch and single messages\n    if (Array.isArray(rawMessage)) {\n      messages = rawMessage.map((msg) => JSONRPCMessageSchema.parse(msg));\n    } else {\n      messages = [JSONRPCMessageSchema.parse(rawMessage)];\n    }\n\n    // check if it contains requests\n    const hasRequests = messages.some(isJSONRPCRequest);\n\n    if (!hasRequests) {\n      // We process without sending anything\n      for (const message of messages) {\n        this.onmessage?.(message, { authInfo, requestInfo });\n      }\n    } else if (hasRequests) {\n      const { connection } = getCurrentAgent();\n      if (!connection)\n        throw new Error(\"Connection was not found in handlePostRequest\");\n\n      // We need to track by request ID to maintain the connection\n      const requestIds = messages\n        .filter(isJSONRPCRequest)\n        .map((message) => message.id);\n\n      connection.setState({\n        requestIds\n      });\n\n      // handle each message\n      for (const message of messages) {\n        this.onmessage?.(message, { authInfo, requestInfo });\n      }\n      // The server SHOULD NOT close the SSE stream before sending all JSON-RPC responses\n      // This will be handled by the send() method when responses are ready\n    }\n  }\n\n  async close(): Promise<void> {\n    // Close all SSE connections\n    const { agent } = getCurrentAgent();\n    if (!agent) throw new Error(\"Agent was not found in close\");\n\n    for (const conn of agent.getConnections()) {\n      conn.close(1000, \"Session closed\");\n    }\n    this.onclose?.();\n  }\n\n  async send(\n    message: JSONRPCMessage,\n    options?: { relatedRequestId?: RequestId }\n  ): Promise<void> {\n    const { agent } = getCurrentAgent();\n    if (!agent) throw new Error(\"Agent was not found in send\");\n\n    let requestId = options?.relatedRequestId;\n    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n      // If the message is a response, use the request ID from the message\n      requestId = message.id;\n    }\n\n    // Check if this message should be sent on the standalone SSE stream (no request ID)\n    // Ignore notifications from tools (which have relatedRequestId set)\n    // Those will be sent via dedicated response SSE streams\n    if (requestId === undefined) {\n      // For standalone SSE streams, we can only send requests and notifications\n      if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n        throw new Error(\n          \"Cannot send a response on a standalone SSE stream unless resuming a previous client request\"\n        );\n      }\n\n      let standaloneConnection: Connection | undefined;\n      for (const conn of agent.getConnections<{ _standaloneSse?: boolean }>()) {\n        if (conn.state?._standaloneSse) standaloneConnection = conn;\n      }\n\n      if (standaloneConnection === undefined) {\n        // The spec says the server MAY send messages on the stream, so it's ok to discard if no stream\n        return;\n      }\n\n      // Generate and store event ID if event store is provided\n      let eventId: string | undefined;\n      if (this._eventStore) {\n        // Stores the event and gets the generated event ID\n        eventId = await this._eventStore.storeEvent(\n          standaloneConnection.id,\n          message\n        );\n      }\n\n      // Send the message to the standalone SSE stream\n      this.writeSSEEvent(standaloneConnection, message, eventId);\n      return;\n    }\n\n    // Get the response for this request\n    const connection = Array.from(\n      agent.getConnections<{ requestIds?: number[] }>()\n    ).find((conn) => conn.state?.requestIds?.includes(requestId as number));\n    if (!connection) {\n      throw new Error(\n        `No connection established for request ID: ${String(requestId)}`\n      );\n    }\n\n    let eventId: string | undefined;\n\n    if (this._eventStore) {\n      eventId = await this._eventStore.storeEvent(connection.id, message);\n    }\n\n    let shouldClose = false;\n\n    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n      this._requestResponseMap.set(requestId, message);\n      const relatedIds = connection.state?.requestIds ?? [];\n      // Check if we have responses for all requests using this connection\n      shouldClose = relatedIds.every((id) => this._requestResponseMap.has(id));\n\n      if (shouldClose) {\n        // Clean up\n        for (const id of relatedIds) {\n          this._requestResponseMap.delete(id);\n        }\n      }\n    }\n    this.writeSSEEvent(connection, message, eventId, shouldClose);\n  }\n}\n","import type { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport type { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport type { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport type { JSONRPCMessage } from \"@modelcontextprotocol/sdk/types.js\";\nimport {\n  JSONRPCMessageSchema,\n  isJSONRPCError,\n  isJSONRPCResponse,\n  type ElicitResult\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { Connection, ConnectionContext } from \"../\";\nimport { Agent } from \"../index\";\nimport type { BaseTransportType, MaybePromise, ServeOptions } from \"./types\";\nimport {\n  createLegacySseHandler,\n  createStreamingHttpHandler,\n  handleCORS,\n  isDurableObjectNamespace,\n  MCP_HTTP_METHOD_HEADER,\n  MCP_MESSAGE_HEADER\n} from \"./utils\";\nimport { McpSSETransport, StreamableHTTPServerTransport } from \"./transport\";\n\nexport abstract class McpAgent<\n  Env = unknown,\n  State = unknown,\n  Props extends Record<string, unknown> = Record<string, unknown>\n> extends Agent<Env, State, Props> {\n  private _transport?: Transport;\n  props?: Props;\n\n  abstract server: MaybePromise<McpServer | Server>;\n  abstract init(): Promise<void>;\n\n  /*\n   * Helpers\n   */\n\n  async setInitializeRequest(initializeRequest: JSONRPCMessage) {\n    await this.ctx.storage.put(\"initializeRequest\", initializeRequest);\n  }\n\n  async getInitializeRequest() {\n    return this.ctx.storage.get<JSONRPCMessage>(\"initializeRequest\");\n  }\n\n  /** Read the transport type for this agent.\n   * This relies on the naming scheme being `sse:${sessionId}`\n   * or `streamable-http:${sessionId}`.\n   */\n  getTransportType(): BaseTransportType {\n    const [t, ..._] = this.name.split(\":\");\n    switch (t) {\n      case \"sse\":\n        return \"sse\";\n      case \"streamable-http\":\n        return \"streamable-http\";\n      default:\n        throw new Error(\n          \"Invalid transport type. McpAgent must be addressed with a valid protocol.\"\n        );\n    }\n  }\n\n  /** Read the sessionId for this agent.\n   * This relies on the naming scheme being `sse:${sessionId}`\n   * or `streamable-http:${sessionId}`.\n   */\n  getSessionId(): string {\n    const [_, sessionId] = this.name.split(\":\");\n    if (!sessionId) {\n      throw new Error(\n        \"Invalid session id. McpAgent must be addressed with a valid session id.\"\n      );\n    }\n    return sessionId;\n  }\n\n  /** Get the unique WebSocket. SSE transport only. */\n  private getWebSocket() {\n    const websockets = Array.from(this.getConnections());\n    if (websockets.length === 0) {\n      return null;\n    }\n    return websockets[0];\n  }\n\n  /** Returns a new transport matching the type of the Agent. */\n  private initTransport() {\n    switch (this.getTransportType()) {\n      case \"sse\": {\n        return new McpSSETransport(() => this.getWebSocket());\n      }\n      case \"streamable-http\": {\n        return new StreamableHTTPServerTransport({});\n      }\n    }\n  }\n\n  /** Update and store the props */\n  async updateProps(props?: Props) {\n    await this.ctx.storage.put(\"props\", props ?? {});\n    this.props = props;\n  }\n\n  async reinitializeServer() {\n    // If the agent was previously initialized, we have to populate\n    // the server again by sending the initialize request to make\n    // client information available to the server.\n    const initializeRequest = await this.getInitializeRequest();\n    if (initializeRequest) {\n      this._transport?.onmessage?.(initializeRequest);\n    }\n  }\n\n  /*\n   * Base Agent / Parykit Server overrides\n   */\n\n  /** Sets up the MCP transport and server every time the Agent is started.*/\n  async onStart(props?: Props) {\n    // If onStart was passed props, save them in storage\n    if (props) await this.updateProps(props);\n    this.props = await this.ctx.storage.get(\"props\");\n\n    await this.init();\n    const server = await this.server;\n    // Connect to the MCP server\n    this._transport = this.initTransport();\n    await server.connect(this._transport);\n    await this.reinitializeServer();\n  }\n\n  /** Validates new WebSocket connections. */\n  async onConnect(\n    conn: Connection,\n    { request: req }: ConnectionContext\n  ): Promise<void> {\n    switch (this.getTransportType()) {\n      case \"sse\": {\n        // For SSE connections, we can only have one open connection per session\n        // If we get an upgrade while already connected, we should error\n        const websockets = Array.from(this.getConnections());\n        if (websockets.length > 1) {\n          conn.close(1008, \"Websocket already connected\");\n          return;\n        }\n        break;\n      }\n      case \"streamable-http\":\n        if (this._transport instanceof StreamableHTTPServerTransport) {\n          switch (req.headers.get(MCP_HTTP_METHOD_HEADER)) {\n            case \"POST\": {\n              // This returns the response directly to the client\n              const payloadHeader = req.headers.get(MCP_MESSAGE_HEADER);\n              let rawPayload: string;\n\n              if (!payloadHeader) {\n                rawPayload = \"{}\";\n              } else {\n                try {\n                  rawPayload = Buffer.from(payloadHeader, \"base64\").toString(\n                    \"utf-8\"\n                  );\n                } catch (_error) {\n                  throw new Error(\n                    \"Internal Server Error: Failed to decode MCP message header\"\n                  );\n                }\n              }\n\n              const parsedBody = JSON.parse(rawPayload);\n              this._transport?.handlePostRequest(req, parsedBody);\n              break;\n            }\n            case \"GET\":\n              this._transport?.handleGetRequest(req);\n              break;\n          }\n        }\n    }\n  }\n\n  /*\n   * Transport ingress and routing\n   */\n\n  /** Handles MCP Messages for the legacy SSE transport. */\n  async onSSEMcpMessage(\n    _sessionId: string,\n    messageBody: unknown\n  ): Promise<Error | null> {\n    // Since we address the DO via both the protocol and the session id,\n    // this should never happen, but let's enforce it just in case\n    if (this.getTransportType() !== \"sse\") {\n      return new Error(\"Internal Server Error: Expected SSE transport\");\n    }\n\n    try {\n      let parsedMessage: JSONRPCMessage;\n      try {\n        parsedMessage = JSONRPCMessageSchema.parse(messageBody);\n      } catch (error) {\n        this._transport?.onerror?.(error as Error);\n        throw error;\n      }\n\n      // Check if this is an elicitation response before passing to transport\n      if (await this._handleElicitationResponse(parsedMessage)) {\n        return null; // Message was handled by elicitation system\n      }\n\n      this._transport?.onmessage?.(parsedMessage);\n      return null;\n    } catch (error) {\n      console.error(\"Error forwarding message to SSE:\", error);\n      this._transport?.onerror?.(error as Error);\n      return error as Error;\n    }\n  }\n\n  /** Elicit user input with a message and schema */\n  async elicitInput(params: {\n    message: string;\n    requestedSchema: unknown;\n  }): Promise<ElicitResult> {\n    const requestId = `elicit_${Math.random().toString(36).substring(2, 11)}`;\n\n    // Store pending request in durable storage\n    await this.ctx.storage.put(`elicitation:${requestId}`, {\n      message: params.message,\n      requestedSchema: params.requestedSchema,\n      timestamp: Date.now()\n    });\n\n    const elicitRequest = {\n      jsonrpc: \"2.0\" as const,\n      id: requestId,\n      method: \"elicitation/create\",\n      params: {\n        message: params.message,\n        requestedSchema: params.requestedSchema\n      }\n    };\n\n    // Send through MCP transport\n    if (this._transport) {\n      await this._transport.send(elicitRequest);\n    } else {\n      const connections = this.getConnections();\n      if (!connections || Array.from(connections).length === 0) {\n        await this.ctx.storage.delete(`elicitation:${requestId}`);\n        throw new Error(\"No active connections available for elicitation\");\n      }\n\n      const connectionList = Array.from(connections);\n      for (const connection of connectionList) {\n        try {\n          connection.send(JSON.stringify(elicitRequest));\n        } catch (error) {\n          console.error(\"Failed to send elicitation request:\", error);\n        }\n      }\n    }\n\n    // Wait for response through MCP\n    return this._waitForElicitationResponse(requestId);\n  }\n\n  /** Wait for elicitation response through storage polling */\n  private async _waitForElicitationResponse(\n    requestId: string\n  ): Promise<ElicitResult> {\n    const startTime = Date.now();\n    const timeout = 60000; // 60 second timeout\n\n    try {\n      while (Date.now() - startTime < timeout) {\n        // Check if response has been stored\n        const response = await this.ctx.storage.get<ElicitResult>(\n          `elicitation:response:${requestId}`\n        );\n        if (response) {\n          // Immediately clean up both request and response\n          await this.ctx.storage.delete(`elicitation:${requestId}`);\n          await this.ctx.storage.delete(`elicitation:response:${requestId}`);\n          return response;\n        }\n\n        // Sleep briefly before checking again\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n\n      throw new Error(\"Elicitation request timed out\");\n    } finally {\n      // Always clean up on timeout or error\n      await this.ctx.storage.delete(`elicitation:${requestId}`);\n      await this.ctx.storage.delete(`elicitation:response:${requestId}`);\n    }\n  }\n\n  /** Handle elicitation responses */\n  private async _handleElicitationResponse(\n    message: JSONRPCMessage\n  ): Promise<boolean> {\n    // Check if this is a response to an elicitation request\n    if (isJSONRPCResponse(message) && message.result) {\n      const requestId = message.id?.toString();\n      if (!requestId || !requestId.startsWith(\"elicit_\")) return false;\n\n      // Check if we have a pending request for this ID\n      const pendingRequest = await this.ctx.storage.get(\n        `elicitation:${requestId}`\n      );\n      if (!pendingRequest) return false;\n\n      // Store the response in durable storage\n      await this.ctx.storage.put(\n        `elicitation:response:${requestId}`,\n        message.result as ElicitResult\n      );\n      return true;\n    }\n\n    // Check if this is an error response to an elicitation request\n    if (isJSONRPCError(message)) {\n      const requestId = message.id?.toString();\n      if (!requestId || !requestId.startsWith(\"elicit_\")) return false;\n\n      // Check if we have a pending request for this ID\n      const pendingRequest = await this.ctx.storage.get(\n        `elicitation:${requestId}`\n      );\n      if (!pendingRequest) return false;\n\n      // Store error response\n      const errorResult: ElicitResult = {\n        action: \"cancel\",\n        content: {\n          error: message.error.message || \"Elicitation request failed\"\n        }\n      };\n      await this.ctx.storage.put(\n        `elicitation:response:${requestId}`,\n        errorResult\n      );\n      return true;\n    }\n\n    return false;\n  }\n\n  /** Return a handler for the given path for this MCP.\n   * Defaults to Streamable HTTP transport.\n   */\n  static serve(\n    path: string,\n    {\n      binding = \"MCP_OBJECT\",\n      corsOptions,\n      transport = \"streamable-http\"\n    }: ServeOptions = {}\n  ) {\n    return {\n      async fetch<Env>(\n        this: void,\n        request: Request,\n        env: Env,\n        ctx: ExecutionContext\n      ): Promise<Response> {\n        // Handle CORS preflight\n        const corsResponse = handleCORS(request, corsOptions);\n        if (corsResponse) {\n          return corsResponse;\n        }\n\n        const bindingValue = env[binding as keyof typeof env] as unknown;\n\n        // Ensure we have a binding of some sort\n        if (bindingValue == null || typeof bindingValue !== \"object\") {\n          throw new Error(\n            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`\n          );\n        }\n\n        // Ensure that the binding is to a DurableObject\n        if (!isDurableObjectNamespace(bindingValue)) {\n          throw new Error(\n            `Invalid McpAgent binding for ${binding}. Make sure it's a Durable Object binding.`\n          );\n        }\n\n        const namespace =\n          bindingValue satisfies DurableObjectNamespace<McpAgent>;\n\n        switch (transport) {\n          case \"streamable-http\": {\n            // Streamable HTTP transport handling\n            const handleStreamableHttp = createStreamingHttpHandler(\n              path,\n              namespace,\n              corsOptions\n            );\n            return handleStreamableHttp(request, ctx);\n          }\n          case \"sse\": {\n            // Legacy SSE transport handling\n            const handleLegacySse = createLegacySseHandler(\n              path,\n              namespace,\n              corsOptions\n            );\n            return handleLegacySse(request, ctx);\n          }\n          default:\n            return new Response(\n              \"Invalid MCP transport mode. Only `streamable-http` or `sse` are allowed.\",\n              { status: 500 }\n            );\n        }\n      }\n    };\n  }\n  /**\n   * Legacy api\n   **/\n  static mount(path: string, opts: Omit<ServeOptions, \"transport\"> = {}) {\n    return McpAgent.serveSSE(path, opts);\n  }\n\n  static serveSSE(path: string, opts: Omit<ServeOptions, \"transport\"> = {}) {\n    return McpAgent.serve(path, { ...opts, transport: \"sse\" });\n  }\n}\n\n// Export client transport classes\nexport { SSEEdgeClientTransport } from \"./sse-edge\";\nexport { StreamableHTTPEdgeClientTransport } from \"./streamable-http-edge\";\n\n// Export elicitation types and schemas\nexport {\n  ElicitRequestSchema,\n  type ElicitRequest,\n  type ElicitResult\n} from \"@modelcontextprotocol/sdk/types.js\";\n\n// Export OAuth-related types\nexport type {\n  MCPClientOAuthResult,\n  MCPClientOAuthCallbackConfig\n} from \"./client\";\n"],"mappings":"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"}