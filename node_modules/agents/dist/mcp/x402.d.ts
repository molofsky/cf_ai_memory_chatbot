import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { CallToolRequest, CallToolResult, CallToolResultSchema, CompatibilityCallToolResultSchema, ToolAnnotations } from "@modelcontextprotocol/sdk/types.js";
import { ZodRawShape } from "zod";
import { Account } from "viem";
import { RequestOptions } from "@modelcontextprotocol/sdk/shared/protocol.js";
import { McpServer, RegisteredTool, ToolCallback } from "@modelcontextprotocol/sdk/server/mcp.js";
import { FacilitatorConfig, Network, PaymentRequirements } from "x402/types";

//#region src/mcp/x402.d.ts

type X402Config = {
  network: Network;
  recipient: `0x${string}`;
  facilitator: FacilitatorConfig;
  version?: number;
};
interface X402AugmentedServer {
  paidTool<Args extends ZodRawShape>(name: string, description: string, priceUSD: number, paramsSchema: Args, annotations: ToolAnnotations, cb: ToolCallback<Args>): RegisteredTool;
}
declare function withX402<T extends McpServer>(server: McpServer, cfg: X402Config): T & X402AugmentedServer;
interface X402AugmentedClient {
  callTool(x402ConfirmationCallback: ((payment: PaymentRequirements[]) => Promise<boolean>) | null, params: CallToolRequest["params"], resultSchema?: typeof CallToolResultSchema | typeof CompatibilityCallToolResultSchema, options?: RequestOptions): Promise<CallToolResult>;
}
type X402ClientConfig = {
  network: Network;
  account: Account;
  maxPaymentValue?: bigint;
  version?: number;
  confirmationCallback?: (payment: PaymentRequirements[]) => Promise<boolean>;
};
declare function withX402Client<T extends Client>(client: T, x402Config: X402ClientConfig): X402AugmentedClient & T;
//#endregion
export { X402AugmentedClient, X402AugmentedServer, X402ClientConfig, X402Config, withX402, withX402Client };
//# sourceMappingURL=x402.d.ts.map