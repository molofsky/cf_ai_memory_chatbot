import { MessageType } from "./ai-types-UZlfLOYP.js";
import { nanoid } from "nanoid";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport, getToolName, isToolUIPart } from "ai";
import { use, useCallback, useEffect, useMemo, useRef } from "react";

//#region src/ai-react.tsx
const requestCache = /* @__PURE__ */ new Map();
/**
* React hook for building AI chat interfaces using an Agent
* @param options Chat options including the agent connection
* @returns Chat interface controls and state with added clearHistory method
*/
/**
* Automatically detects which tools require confirmation based on their configuration.
* Tools require confirmation if they have no execute function AND are not server-executed.
* @param tools - Record of tool name to tool definition
* @returns Array of tool names that require confirmation
*/
function detectToolsRequiringConfirmation(tools) {
	if (!tools) return [];
	return Object.entries(tools).filter(([_name, tool$1]) => !tool$1.execute).map(([name]) => name);
}
function useAgentChat(options) {
	const { agent, getInitialMessages, messages: optionsInitialMessages, experimental_automaticToolResolution, tools, toolsRequiringConfirmation: manualToolsRequiringConfirmation, autoSendAfterAllConfirmationsResolved = true,...rest } = options;
	const toolsRequiringConfirmation = manualToolsRequiringConfirmation ?? detectToolsRequiringConfirmation(tools);
	const agentUrl = new URL(`${(agent._url || agent._pkurl)?.replace("ws://", "http://").replace("wss://", "https://")}`);
	agentUrl.searchParams.delete("_pk");
	const agentUrlString = agentUrl.toString();
	const initialMessagesCacheKey = `${agentUrlString}|${agent.agent ?? ""}|${agent.name ?? ""}`;
	const agentRef = useRef(agent);
	useEffect(() => {
		agentRef.current = agent;
	}, [agent]);
	async function defaultGetInitialMessagesFetch({ url }) {
		const getMessagesUrl = new URL(url);
		getMessagesUrl.pathname += "/get-messages";
		const response = await fetch(getMessagesUrl.toString(), {
			credentials: options.credentials,
			headers: options.headers
		});
		if (!response.ok) {
			console.warn(`Failed to fetch initial messages: ${response.status} ${response.statusText}`);
			return [];
		}
		const text = await response.text();
		if (!text.trim()) return [];
		try {
			return JSON.parse(text);
		} catch (error) {
			console.warn("Failed to parse initial messages JSON:", error);
			return [];
		}
	}
	const getInitialMessagesFetch = getInitialMessages || defaultGetInitialMessagesFetch;
	function doGetInitialMessages(getInitialMessagesOptions, cacheKey) {
		if (requestCache.has(cacheKey)) return requestCache.get(cacheKey);
		const promise = getInitialMessagesFetch(getInitialMessagesOptions);
		requestCache.set(cacheKey, promise);
		return promise;
	}
	const initialMessagesPromise = getInitialMessages === null ? null : doGetInitialMessages({
		agent: agent.agent,
		name: agent.name,
		url: agentUrlString
	}, initialMessagesCacheKey);
	const initialMessages = initialMessagesPromise ? use(initialMessagesPromise) : optionsInitialMessages ?? [];
	useEffect(() => {
		if (!initialMessagesPromise) return;
		requestCache.set(initialMessagesCacheKey, initialMessagesPromise);
		return () => {
			if (requestCache.get(initialMessagesCacheKey) === initialMessagesPromise) requestCache.delete(initialMessagesCacheKey);
		};
	}, [initialMessagesCacheKey, initialMessagesPromise]);
	const aiFetch = useCallback(async (request, options$1 = {}) => {
		const { method, keepalive, headers, body, redirect, integrity, signal, credentials, mode, referrer, referrerPolicy, window } = options$1;
		const id = nanoid(8);
		const abortController = new AbortController();
		let controller;
		const currentAgent = agentRef.current;
		signal?.addEventListener("abort", () => {
			currentAgent.send(JSON.stringify({
				id,
				type: MessageType.CF_AGENT_CHAT_REQUEST_CANCEL
			}));
			abortController.abort();
			controller.close();
		});
		currentAgent.addEventListener("message", (event) => {
			let data;
			try {
				data = JSON.parse(event.data);
			} catch (_error) {
				return;
			}
			if (data.type === MessageType.CF_AGENT_USE_CHAT_RESPONSE) {
				if (data.id === id) if (data.error) {
					controller.error(new Error(data.body));
					abortController.abort();
				} else {
					if (data.body?.trim()) controller.enqueue(new TextEncoder().encode(`data: ${data.body}\n\n`));
					if (data.done) {
						controller.close();
						abortController.abort();
					}
				}
			}
		}, { signal: abortController.signal });
		const stream = new ReadableStream({ start(c) {
			controller = c;
		} });
		currentAgent.send(JSON.stringify({
			id,
			init: {
				body,
				credentials,
				headers,
				integrity,
				keepalive,
				method,
				mode,
				redirect,
				referrer,
				referrerPolicy,
				window
			},
			type: MessageType.CF_AGENT_USE_CHAT_REQUEST,
			url: request.toString()
		}));
		return new Response(stream);
	}, []);
	const customTransport = useMemo(() => ({
		sendMessages: async (options$1) => {
			return new DefaultChatTransport({
				api: agentUrlString,
				fetch: aiFetch
			}).sendMessages(options$1);
		},
		reconnectToStream: async (options$1) => {
			return new DefaultChatTransport({
				api: agentUrlString,
				fetch: aiFetch
			}).reconnectToStream(options$1);
		}
	}), [agentUrlString, aiFetch]);
	const useChatHelpers = useChat({
		...rest,
		messages: initialMessages,
		transport: customTransport,
		id: agent._pk
	});
	const processedToolCalls = useRef(/* @__PURE__ */ new Set());
	const lastMessage = useChatHelpers.messages[useChatHelpers.messages.length - 1];
	const pendingConfirmations = (() => {
		if (!lastMessage || lastMessage.role !== "assistant") return {
			messageId: void 0,
			toolCallIds: /* @__PURE__ */ new Set()
		};
		const pendingIds = /* @__PURE__ */ new Set();
		for (const part of lastMessage.parts ?? []) if (isToolUIPart(part) && part.state === "input-available" && toolsRequiringConfirmation.includes(getToolName(part))) pendingIds.add(part.toolCallId);
		return {
			messageId: lastMessage.id,
			toolCallIds: pendingIds
		};
	})();
	const pendingConfirmationsRef = useRef(pendingConfirmations);
	pendingConfirmationsRef.current = pendingConfirmations;
	useEffect(() => {
		if (!experimental_automaticToolResolution) return;
		const lastMessage$1 = useChatHelpers.messages[useChatHelpers.messages.length - 1];
		if (!lastMessage$1 || lastMessage$1.role !== "assistant") return;
		const toolCalls = lastMessage$1.parts.filter((part) => isToolUIPart(part) && part.state === "input-available" && !processedToolCalls.current.has(part.toolCallId));
		if (toolCalls.length > 0) (async () => {
			const toolCallsToResolve = toolCalls.filter((part) => isToolUIPart(part) && !toolsRequiringConfirmation.includes(getToolName(part)) && tools?.[getToolName(part)]?.execute);
			if (toolCallsToResolve.length > 0) {
				for (const part of toolCallsToResolve) if (isToolUIPart(part)) {
					processedToolCalls.current.add(part.toolCallId);
					let toolOutput = null;
					const toolName = getToolName(part);
					const tool$1 = tools?.[toolName];
					if (tool$1?.execute && part.input) try {
						toolOutput = await tool$1.execute(part.input);
					} catch (error) {
						toolOutput = `Error executing tool: ${error instanceof Error ? error.message : String(error)}`;
					}
					await useChatHelpers.addToolResult({
						toolCallId: part.toolCallId,
						tool: toolName,
						output: toolOutput
					});
				}
				if (pendingConfirmationsRef.current.toolCallIds.size === 0) useChatHelpers.sendMessage();
			}
		})();
	}, [
		useChatHelpers.messages,
		experimental_automaticToolResolution,
		useChatHelpers.addToolResult,
		useChatHelpers.sendMessage,
		toolsRequiringConfirmation
	]);
	useEffect(() => {
		function onClearHistory(event) {
			if (typeof event.data !== "string") return;
			let data;
			try {
				data = JSON.parse(event.data);
			} catch (_error) {
				return;
			}
			if (data.type === MessageType.CF_AGENT_CHAT_CLEAR) useChatHelpers.setMessages([]);
		}
		function onMessages(event) {
			if (typeof event.data !== "string") return;
			let data;
			try {
				data = JSON.parse(event.data);
			} catch (_error) {
				return;
			}
			if (data.type === MessageType.CF_AGENT_CHAT_MESSAGES) useChatHelpers.setMessages(data.messages);
		}
		agent.addEventListener("message", onClearHistory);
		agent.addEventListener("message", onMessages);
		return () => {
			agent.removeEventListener("message", onClearHistory);
			agent.removeEventListener("message", onMessages);
		};
	}, [agent, useChatHelpers.setMessages]);
	const addToolResultAndSendMessage = async (args) => {
		const { toolCallId } = args;
		await useChatHelpers.addToolResult(args);
		if (!autoSendAfterAllConfirmationsResolved) {
			useChatHelpers.sendMessage();
			return;
		}
		const pending = pendingConfirmationsRef.current?.toolCallIds;
		if (!pending) {
			useChatHelpers.sendMessage();
			return;
		}
		const wasLast = pending.size === 1 && pending.has(toolCallId);
		if (pending.has(toolCallId)) pending.delete(toolCallId);
		if (wasLast || pending.size === 0) useChatHelpers.sendMessage();
	};
	return {
		...useChatHelpers,
		addToolResult: addToolResultAndSendMessage,
		clearHistory: () => {
			useChatHelpers.setMessages([]);
			agent.send(JSON.stringify({ type: MessageType.CF_AGENT_CHAT_CLEAR }));
		},
		setMessages: (messages) => {
			useChatHelpers.setMessages(messages);
			agent.send(JSON.stringify({
				messages: Array.isArray(messages) ? messages : [],
				type: MessageType.CF_AGENT_CHAT_MESSAGES
			}));
		}
	};
}

//#endregion
export { detectToolsRequiringConfirmation, useAgentChat };
//# sourceMappingURL=ai-react.js.map