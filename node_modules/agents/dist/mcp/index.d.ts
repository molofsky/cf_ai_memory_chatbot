import { BaseTransportType, MCPClientOAuthCallbackConfig, MCPClientOAuthResult, MaybePromise, SSEEdgeClientTransport, ServeOptions, StreamableHTTPEdgeClientTransport } from "../client-CrWcaPgn.js";
import "../mcp-BEwaCsxO.js";
import "../do-oauth-client-provider-CCwGwnrA.js";
import "../index-W4JUkafc.js";
import "../ai-types-BWW4umHY.js";
import { Agent, Connection, ConnectionContext } from "../index-DpH9o0ao.js";
import { ElicitRequest, ElicitRequestSchema, ElicitResult, ElicitResult as ElicitResult$1, JSONRPCMessage } from "@modelcontextprotocol/sdk/types.js";
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

//#region src/mcp/index.d.ts
declare abstract class McpAgent<Env = unknown, State = unknown, Props extends Record<string, unknown> = Record<string, unknown>> extends Agent<Env, State, Props> {
  private _transport?;
  props?: Props;
  abstract server: MaybePromise<McpServer | Server>;
  abstract init(): Promise<void>;
  setInitializeRequest(initializeRequest: JSONRPCMessage): Promise<void>;
  getInitializeRequest(): Promise<JSONRPCMessage | undefined>;
  /** Read the transport type for this agent.
   * This relies on the naming scheme being `sse:${sessionId}`
   * or `streamable-http:${sessionId}`.
   */
  getTransportType(): BaseTransportType;
  /** Read the sessionId for this agent.
   * This relies on the naming scheme being `sse:${sessionId}`
   * or `streamable-http:${sessionId}`.
   */
  getSessionId(): string;
  /** Get the unique WebSocket. SSE transport only. */
  private getWebSocket;
  /** Returns a new transport matching the type of the Agent. */
  private initTransport;
  /** Update and store the props */
  updateProps(props?: Props): Promise<void>;
  reinitializeServer(): Promise<void>;
  /** Sets up the MCP transport and server every time the Agent is started.*/
  onStart(props?: Props): Promise<void>;
  /** Validates new WebSocket connections. */
  onConnect(conn: Connection, {
    request: req
  }: ConnectionContext): Promise<void>;
  /** Handles MCP Messages for the legacy SSE transport. */
  onSSEMcpMessage(_sessionId: string, messageBody: unknown): Promise<Error | null>;
  /** Elicit user input with a message and schema */
  elicitInput(params: {
    message: string;
    requestedSchema: unknown;
  }): Promise<ElicitResult$1>;
  /** Wait for elicitation response through storage polling */
  private _waitForElicitationResponse;
  /** Handle elicitation responses */
  private _handleElicitationResponse;
  /** Return a handler for the given path for this MCP.
   * Defaults to Streamable HTTP transport.
   */
  static serve(path: string, {
    binding,
    corsOptions,
    transport
  }?: ServeOptions): {
    fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
  };
  /**
   * Legacy api
   **/
  static mount(path: string, opts?: Omit<ServeOptions, "transport">): {
    fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
  };
  static serveSSE(path: string, opts?: Omit<ServeOptions, "transport">): {
    fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
  };
}
//#endregion
export { type ElicitRequest, ElicitRequestSchema, type ElicitResult, type MCPClientOAuthCallbackConfig, type MCPClientOAuthResult, McpAgent, SSEEdgeClientTransport, StreamableHTTPEdgeClientTransport };
//# sourceMappingURL=index.d.ts.map