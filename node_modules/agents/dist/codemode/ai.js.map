{"version":3,"file":"ai.js","names":["tool","compileJsonSchemaToTs","printNodeZodToTs"],"sources":["../../src/codemode/ai.ts"],"sourcesContent":["import { generateObject, tool, type ToolSet } from \"ai\";\nimport { openai } from \"@ai-sdk/openai\";\nimport { z } from \"zod/v3\";\nimport { compile as compileJsonSchemaToTs } from \"json-schema-to-typescript\";\nimport {\n  zodToTs,\n  printNode as printNodeZodToTs,\n  createTypeAlias\n} from \"zod-to-ts\";\nimport { getAgentByName } from \"..\";\nimport { env, WorkerEntrypoint } from \"cloudflare:workers\";\n\nfunction toCamelCase(str: string) {\n  return str\n    .replace(/_([a-z])/g, (_, letter) => letter.toUpperCase())\n    .replace(/^[a-z]/, (letter) => letter.toUpperCase());\n}\n\nexport class CodeModeProxy extends WorkerEntrypoint<\n  Cloudflare.Env,\n  {\n    binding: string;\n    name: string;\n    callback: string;\n  }\n> {\n  async callFunction(options: { functionName: string; args: unknown[] }) {\n    const stub = (await getAgentByName(\n      // @ts-expect-error\n      env[this.ctx.props.binding] as AgentNamespace<T>,\n      this.ctx.props.name\n    )) as DurableObjectStub;\n    // @ts-expect-error\n    return stub[this.ctx.props.callback](options.functionName, options.args);\n  }\n}\n\nexport async function experimental_codemode(options: {\n  tools: ToolSet;\n  prompt: string;\n  globalOutbound: Fetcher;\n  loader: WorkerLoader;\n  proxy: Fetcher<CodeModeProxy>;\n}): Promise<{\n  prompt: string;\n  tools: ToolSet;\n}> {\n  const generatedTypes = await generateTypes(options.tools);\n  const prompt = `You are a helpful assistant. You have access to the \"codemode\" tool that can do different things: \n  \n  ${getToolDescriptions(options.tools)} \n  \n  If the user asks to do anything that be achieveable by the codemode tool, then simply pass over control to it by giving it a simple function description. Don't be too verbose.\n  \n  `;\n\n  const codemodeTool = tool({\n    description: \"codemode: a tool that can generate code to achieve a goal\",\n    inputSchema: z.object({\n      functionDescription: z.string()\n    }),\n    outputSchema: z.object({\n      code: z.string(),\n      result: z.any()\n    }),\n    execute: async ({ functionDescription }) => {\n      try {\n        const response = await generateObject({\n          model: openai(\"gpt-4.1\"),\n          schema: z.object({\n            code: z.string()\n          }),\n          prompt: `You are a code generating machine.\n\n      In addition to regular javascript, you can also use the following functions:\n\n      ${generatedTypes}      \n\n      Respond only with the code, nothing else. Output javascript code.\n\n      Generate an async function that achieves the goal. This async function doesn't accept any arguments.\n\n      Here is user input: ${functionDescription}` // insert ts types for the tools here\n        });\n\n        // console.log(\"args\", response.object.args);\n        const evaluator = createEvaluator(response.object.code, {\n          proxy: options.proxy,\n          loader: options.loader\n        });\n        const result = await evaluator();\n        return { code: response.object.code, result: result };\n      } catch (error) {\n        console.error(\"error\", error);\n        throw error;\n        // return { code: \"\", result: error };\n      }\n    }\n  });\n\n  return { prompt, tools: { codemode: codemodeTool } };\n}\n\nfunction createEvaluator(\n  code: string,\n  options: {\n    loader: WorkerLoader;\n    proxy: Fetcher<CodeModeProxy>;\n  }\n) {\n  return async () => {\n    const worker = options.loader.get(`code-${Math.random()}`, () => {\n      return {\n        compatibilityDate: \"2025-06-01\",\n        compatibilityFlags: [\"nodejs_compat\"],\n        mainModule: \"foo.js\",\n        modules: {\n          \"foo.js\": `\nimport { env, WorkerEntrypoint } from \"cloudflare:workers\";\n\nexport default class CodeModeWorker extends WorkerEntrypoint {\n  async evaluate() {\n    try {\n      const { CodeModeProxy } = env;\n      const codemode = new Proxy(\n        {},\n        {\n          get: (target, prop) => {\n            return (args) => {\n              return CodeModeProxy.callFunction({\n                functionName: prop,\n                args: args,                \n              });\n            };\n          }\n        }\n      );\n\n      return await ${code}();\n    } catch (err) {\n      return {\n        err: err.message,\n        stack: err.stack\n      };\n    }\n  }\n}\n            \n        `\n        },\n        env: {\n          // insert keys and bindings to tools/ts functions here\n          CodeModeProxy: options.proxy\n        },\n        globalOutbound: null\n      };\n    });\n\n    // @ts-expect-error TODO: fix this\n    return await worker.getEntrypoint().evaluate();\n  };\n}\n\nasync function generateTypes(tools: ToolSet) {\n  let availableTools = \"\";\n  let availableTypes = \"\";\n\n  for (const [toolName, tool] of Object.entries(tools)) {\n    // @ts-expect-error TODO: fix this\n    const inputJsonType = tool.inputSchema.jsonSchema\n      ? await compileJsonSchemaToTs(\n          // @ts-expect-error TODO: fix this\n          tool.inputSchema.jsonSchema,\n          `${toCamelCase(toolName)}Input`,\n          {\n            format: false,\n            bannerComment: \" \"\n          }\n        )\n      : printNodeZodToTs(\n          createTypeAlias(\n            zodToTs(\n              // @ts-expect-error TODO: fix this\n              tool.inputSchema,\n              `${toCamelCase(toolName)}Input`\n            ).node,\n            `${toCamelCase(toolName)}Input`\n          )\n        );\n\n    const outputJsonType =\n      // @ts-expect-error TODO: fix this\n      tool.outputSchema?.jsonSchema\n        ? await compileJsonSchemaToTs(\n            // @ts-expect-error TODO: fix this\n            tool.outputSchema?.jsonSchema,\n            `${toCamelCase(toolName)}Output`,\n            {\n              format: false,\n              bannerComment: \" \"\n            }\n          )\n        : tool.outputSchema\n          ? printNodeZodToTs(\n              createTypeAlias(\n                zodToTs(\n                  // @ts-expect-error TODO: fix this\n                  tool.outputSchema,\n                  `${toCamelCase(toolName)}Output`\n                ).node,\n                `${toCamelCase(toolName)}Output`\n              )\n            )\n          : `interface ${toCamelCase(toolName)}Output { [key: string]: any }`;\n\n    const InputType = inputJsonType\n      .trim()\n      .replace(\"export interface\", \"interface\");\n\n    const OutputType = outputJsonType\n      .trim()\n      .replace(\"export interface\", \"interface\");\n\n    availableTypes += `\\n${InputType}`;\n    availableTypes += `\\n${OutputType}`;\n    availableTools += `\\n\\t/*\\n\\t${tool.description?.trim()}\\n\\t*/`;\n    availableTools += `\\n\\t${toolName}: (input: ${toCamelCase(toolName)}Input) => Promise<${toCamelCase(toolName)}Output>;`;\n    availableTools += \"\\n\";\n  }\n\n  availableTools = `\\ndeclare const codemode: {${availableTools}}`;\n\n  return `\n${availableTypes}\n${availableTools}\n      `;\n}\n\nfunction getToolDescriptions(tools: ToolSet) {\n  return Object.entries(tools)\n    .map(([_toolName, tool]) => {\n      return `\\n- ${tool.description?.trim()}`;\n    })\n    .join(\"\");\n}\n"],"mappings":"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"}