{"version":3,"file":"ai-react.js","names":["tool","options","controller: ReadableStreamDefaultController","data: OutgoingMessage<ChatMessage>","customTransport: ChatTransport<ChatMessage>","lastMessage","data: OutgoingMessage","addToolResultAndSendMessage: typeof useChatHelpers.addToolResult"],"sources":["../src/ai-react.tsx"],"sourcesContent":["import { useChat, type UseChatOptions } from \"@ai-sdk/react\";\nimport { getToolName, isToolUIPart } from \"ai\";\nimport type {\n  ChatInit,\n  ChatTransport,\n  UIMessage as Message,\n  UIMessage\n} from \"ai\";\nimport { DefaultChatTransport } from \"ai\";\nimport { nanoid } from \"nanoid\";\nimport { use, useCallback, useEffect, useMemo, useRef } from \"react\";\nimport type { OutgoingMessage } from \"./ai-types\";\nimport { MessageType } from \"./ai-types\";\nimport type { useAgent } from \"./react\";\n\nexport type AITool<Input = unknown, Output = unknown> = {\n  description?: string;\n  inputSchema?: unknown;\n  execute?: (input: Input) => Output | Promise<Output>;\n};\n\ntype GetInitialMessagesOptions = {\n  agent: string;\n  name: string;\n  url: string;\n};\n\n// v5 useChat parameters\ntype UseChatParams<M extends UIMessage = UIMessage> = ChatInit<M> &\n  UseChatOptions<M>;\n\n/**\n * Options for the useAgentChat hook\n */\ntype UseAgentChatOptions<\n  State,\n  ChatMessage extends UIMessage = UIMessage\n> = Omit<UseChatParams<ChatMessage>, \"fetch\"> & {\n  /** Agent connection from useAgent */\n  agent: ReturnType<typeof useAgent<State>>;\n  getInitialMessages?:\n    | undefined\n    | null\n    | ((options: GetInitialMessagesOptions) => Promise<ChatMessage[]>);\n  /** Request credentials */\n  credentials?: RequestCredentials;\n  /** Request headers */\n  headers?: HeadersInit;\n  /**\n   * @description Whether to automatically resolve tool calls that do not require human interaction.\n   * @experimental\n   */\n  experimental_automaticToolResolution?: boolean;\n  /**\n   * @description Tools object for automatic detection of confirmation requirements.\n   * Tools without execute function will require confirmation.\n   */\n  tools?: Record<string, AITool<unknown, unknown>>;\n  /**\n   * @description Manual override for tools requiring confirmation.\n   * If not provided, will auto-detect from tools object.\n   */\n  toolsRequiringConfirmation?: string[];\n  /**\n   * When true (default), automatically sends the next message only after\n   * all pending confirmation-required tool calls have been resolved.\n   * @default true\n   */\n  autoSendAfterAllConfirmationsResolved?: boolean;\n};\n\nconst requestCache = new Map<string, Promise<Message[]>>();\n\n/**\n * React hook for building AI chat interfaces using an Agent\n * @param options Chat options including the agent connection\n * @returns Chat interface controls and state with added clearHistory method\n */\n/**\n * Automatically detects which tools require confirmation based on their configuration.\n * Tools require confirmation if they have no execute function AND are not server-executed.\n * @param tools - Record of tool name to tool definition\n * @returns Array of tool names that require confirmation\n */\nexport function detectToolsRequiringConfirmation(\n  tools?: Record<string, AITool<unknown, unknown>>\n): string[] {\n  if (!tools) return [];\n\n  return Object.entries(tools)\n    .filter(([_name, tool]) => !tool.execute)\n    .map(([name]) => name);\n}\n\nexport function useAgentChat<\n  State = unknown,\n  ChatMessage extends UIMessage = UIMessage\n>(\n  options: UseAgentChatOptions<State, ChatMessage>\n): ReturnType<typeof useChat<ChatMessage>> & {\n  clearHistory: () => void;\n} {\n  const {\n    agent,\n    getInitialMessages,\n    messages: optionsInitialMessages,\n    experimental_automaticToolResolution,\n    tools,\n    toolsRequiringConfirmation: manualToolsRequiringConfirmation,\n    autoSendAfterAllConfirmationsResolved = true,\n    ...rest\n  } = options;\n\n  // Auto-detect tools requiring confirmation, or use manual override\n  const toolsRequiringConfirmation =\n    manualToolsRequiringConfirmation ?? detectToolsRequiringConfirmation(tools);\n\n  const agentUrl = new URL(\n    `${// @ts-expect-error we're using a protected _url property that includes query params\n    ((agent._url as string | null) || agent._pkurl)\n      ?.replace(\"ws://\", \"http://\")\n      .replace(\"wss://\", \"https://\")}`\n  );\n\n  agentUrl.searchParams.delete(\"_pk\");\n  const agentUrlString = agentUrl.toString();\n\n  // we need to include agent.name in cache key to prevent collisions during agent switching.\n  // The URL may be stale between updateProperties() and reconnect(), but agent.name\n  // is updated synchronously, so each thread gets its own cache entry\n  const initialMessagesCacheKey = `${agentUrlString}|${agent.agent ?? \"\"}|${agent.name ?? \"\"}`;\n\n  // Keep a ref to always point to the latest agent instance\n  const agentRef = useRef(agent);\n  useEffect(() => {\n    agentRef.current = agent;\n  }, [agent]);\n\n  async function defaultGetInitialMessagesFetch({\n    url\n  }: GetInitialMessagesOptions) {\n    const getMessagesUrl = new URL(url);\n    getMessagesUrl.pathname += \"/get-messages\";\n    const response = await fetch(getMessagesUrl.toString(), {\n      credentials: options.credentials,\n      headers: options.headers\n    });\n\n    if (!response.ok) {\n      console.warn(\n        `Failed to fetch initial messages: ${response.status} ${response.statusText}`\n      );\n      return [];\n    }\n\n    const text = await response.text();\n    if (!text.trim()) {\n      return [];\n    }\n\n    try {\n      return JSON.parse(text) as ChatMessage[];\n    } catch (error) {\n      console.warn(\"Failed to parse initial messages JSON:\", error);\n      return [];\n    }\n  }\n\n  const getInitialMessagesFetch =\n    getInitialMessages || defaultGetInitialMessagesFetch;\n\n  function doGetInitialMessages(\n    getInitialMessagesOptions: GetInitialMessagesOptions,\n    cacheKey: string\n  ) {\n    if (requestCache.has(cacheKey)) {\n      return requestCache.get(cacheKey)! as Promise<ChatMessage[]>;\n    }\n    const promise = getInitialMessagesFetch(getInitialMessagesOptions);\n    requestCache.set(cacheKey, promise);\n    return promise;\n  }\n\n  const initialMessagesPromise =\n    getInitialMessages === null\n      ? null\n      : doGetInitialMessages(\n          {\n            agent: agent.agent,\n            name: agent.name,\n            url: agentUrlString\n          },\n          initialMessagesCacheKey\n        );\n  const initialMessages = initialMessagesPromise\n    ? use(initialMessagesPromise)\n    : (optionsInitialMessages ?? []);\n\n  useEffect(() => {\n    if (!initialMessagesPromise) {\n      return;\n    }\n    requestCache.set(initialMessagesCacheKey, initialMessagesPromise!);\n    return () => {\n      if (\n        requestCache.get(initialMessagesCacheKey) === initialMessagesPromise\n      ) {\n        requestCache.delete(initialMessagesCacheKey);\n      }\n    };\n  }, [initialMessagesCacheKey, initialMessagesPromise]);\n\n  const aiFetch = useCallback(\n    async (request: RequestInfo | URL, options: RequestInit = {}) => {\n      const {\n        method,\n        keepalive,\n        headers,\n        body,\n        redirect,\n        integrity,\n        signal,\n        credentials,\n        mode,\n        referrer,\n        referrerPolicy,\n        window\n      } = options;\n      const id = nanoid(8);\n      const abortController = new AbortController();\n      let controller: ReadableStreamDefaultController;\n      const currentAgent = agentRef.current;\n\n      signal?.addEventListener(\"abort\", () => {\n        currentAgent.send(\n          JSON.stringify({\n            id,\n            type: MessageType.CF_AGENT_CHAT_REQUEST_CANCEL\n          })\n        );\n\n        // NOTE - If we wanted to, we could preserve the \"interrupted\" message here, with the code below\n        //        However, I think it might be the responsibility of the library user to implement that behavior manually?\n        //        Reasoning: This code could be subject to collisions, as it \"force saves\" the messages we have locally\n        //\n        // agent.send(JSON.stringify({\n        //   type: MessageType.CF_AGENT_CHAT_MESSAGES,\n        //   messages: ... /* some way of getting current messages ref? */\n        // }))\n\n        abortController.abort();\n        // Make sure to also close the stream (cf. https://github.com/cloudflare/agents-starter/issues/69)\n        controller.close();\n      });\n\n      currentAgent.addEventListener(\n        \"message\",\n        (event) => {\n          let data: OutgoingMessage<ChatMessage>;\n          try {\n            data = JSON.parse(event.data) as OutgoingMessage<ChatMessage>;\n          } catch (_error) {\n            // silently ignore invalid messages for now\n            // TODO: log errors with log levels\n            return;\n          }\n          if (data.type === MessageType.CF_AGENT_USE_CHAT_RESPONSE) {\n            if (data.id === id) {\n              if (data.error) {\n                controller.error(new Error(data.body));\n                abortController.abort();\n              } else {\n                // Only enqueue non-empty data to prevent JSON parsing errors\n                if (data.body?.trim()) {\n                  controller.enqueue(\n                    new TextEncoder().encode(`data: ${data.body}\\n\\n`)\n                  );\n                }\n                if (data.done) {\n                  controller.close();\n                  abortController.abort();\n                }\n              }\n            }\n          }\n        },\n        { signal: abortController.signal }\n      );\n\n      const stream = new ReadableStream({\n        start(c) {\n          controller = c;\n        }\n      });\n\n      currentAgent.send(\n        JSON.stringify({\n          id,\n          init: {\n            body,\n            credentials,\n            headers,\n            integrity,\n            keepalive,\n            method,\n            mode,\n            redirect,\n            referrer,\n            referrerPolicy,\n            window\n          },\n          type: MessageType.CF_AGENT_USE_CHAT_REQUEST,\n          url: request.toString()\n        })\n      );\n\n      return new Response(stream);\n    },\n    []\n  );\n\n  const customTransport: ChatTransport<ChatMessage> = useMemo(\n    () => ({\n      sendMessages: async (\n        options: Parameters<\n          typeof DefaultChatTransport.prototype.sendMessages\n        >[0]\n      ) => {\n        const transport = new DefaultChatTransport<ChatMessage>({\n          api: agentUrlString,\n          fetch: aiFetch\n        });\n        return transport.sendMessages(options);\n      },\n      reconnectToStream: async (\n        options: Parameters<\n          typeof DefaultChatTransport.prototype.reconnectToStream\n        >[0]\n      ) => {\n        const transport = new DefaultChatTransport<ChatMessage>({\n          api: agentUrlString,\n          fetch: aiFetch\n        });\n        return transport.reconnectToStream(options);\n      }\n    }),\n    [agentUrlString, aiFetch]\n  );\n\n  const useChatHelpers = useChat<ChatMessage>({\n    ...rest,\n    messages: initialMessages,\n    transport: customTransport,\n    id: agent._pk\n  });\n\n  const processedToolCalls = useRef(new Set<string>());\n\n  // Calculate pending confirmations for the latest assistant message\n  const lastMessage =\n    useChatHelpers.messages[useChatHelpers.messages.length - 1];\n\n  const pendingConfirmations = (() => {\n    if (!lastMessage || lastMessage.role !== \"assistant\") {\n      return { messageId: undefined, toolCallIds: new Set<string>() };\n    }\n\n    const pendingIds = new Set<string>();\n    for (const part of lastMessage.parts ?? []) {\n      if (\n        isToolUIPart(part) &&\n        part.state === \"input-available\" &&\n        toolsRequiringConfirmation.includes(getToolName(part))\n      ) {\n        pendingIds.add(part.toolCallId);\n      }\n    }\n    return { messageId: lastMessage.id, toolCallIds: pendingIds };\n  })();\n\n  const pendingConfirmationsRef = useRef(pendingConfirmations);\n  pendingConfirmationsRef.current = pendingConfirmations;\n\n  // tools can be a different object everytime it's called,\n  // which might lead to this effect being called multiple times with different tools objects.\n  // we need to fix this, but that's a bigger refactor.\n  // biome-ignore lint/correctness/useExhaustiveDependencies: we need to fix this\n  useEffect(() => {\n    if (!experimental_automaticToolResolution) {\n      return;\n    }\n\n    const lastMessage =\n      useChatHelpers.messages[useChatHelpers.messages.length - 1];\n    if (!lastMessage || lastMessage.role !== \"assistant\") {\n      return;\n    }\n\n    const toolCalls = lastMessage.parts.filter(\n      (part) =>\n        isToolUIPart(part) &&\n        part.state === \"input-available\" &&\n        !processedToolCalls.current.has(part.toolCallId)\n    );\n\n    if (toolCalls.length > 0) {\n      (async () => {\n        const toolCallsToResolve = toolCalls.filter(\n          (part) =>\n            isToolUIPart(part) &&\n            !toolsRequiringConfirmation.includes(getToolName(part)) &&\n            tools?.[getToolName(part)]?.execute // Only execute if client has execute function\n        );\n\n        if (toolCallsToResolve.length > 0) {\n          for (const part of toolCallsToResolve) {\n            if (isToolUIPart(part)) {\n              processedToolCalls.current.add(part.toolCallId);\n              let toolOutput = null;\n              const toolName = getToolName(part);\n              const tool = tools?.[toolName];\n\n              if (tool?.execute && part.input) {\n                try {\n                  toolOutput = await tool.execute(part.input);\n                } catch (error) {\n                  toolOutput = `Error executing tool: ${error instanceof Error ? error.message : String(error)}`;\n                }\n              }\n\n              await useChatHelpers.addToolResult({\n                toolCallId: part.toolCallId,\n                tool: toolName,\n                output: toolOutput\n              });\n            }\n          }\n          // If there are NO pending confirmations for the latest assistant message,\n          // we can continue the conversation. Otherwise, wait for the UI to resolve\n          // those confirmations; the addToolResult wrapper will send when the last\n          // pending confirmation is resolved.\n          if (pendingConfirmationsRef.current.toolCallIds.size === 0) {\n            useChatHelpers.sendMessage();\n          }\n        }\n      })();\n    }\n  }, [\n    useChatHelpers.messages,\n    experimental_automaticToolResolution,\n    useChatHelpers.addToolResult,\n    useChatHelpers.sendMessage,\n    toolsRequiringConfirmation\n  ]);\n\n  useEffect(() => {\n    function onClearHistory(event: MessageEvent) {\n      if (typeof event.data !== \"string\") return;\n      let data: OutgoingMessage;\n      try {\n        data = JSON.parse(event.data) as OutgoingMessage;\n      } catch (_error) {\n        return;\n      }\n      if (data.type === MessageType.CF_AGENT_CHAT_CLEAR) {\n        useChatHelpers.setMessages([]);\n      }\n    }\n\n    function onMessages(event: MessageEvent) {\n      if (typeof event.data !== \"string\") return;\n      let data: OutgoingMessage<ChatMessage>;\n      try {\n        data = JSON.parse(event.data) as OutgoingMessage<ChatMessage>;\n      } catch (_error) {\n        return;\n      }\n      if (data.type === MessageType.CF_AGENT_CHAT_MESSAGES) {\n        useChatHelpers.setMessages(data.messages);\n      }\n    }\n\n    agent.addEventListener(\"message\", onClearHistory);\n    agent.addEventListener(\"message\", onMessages);\n\n    return () => {\n      agent.removeEventListener(\"message\", onClearHistory);\n      agent.removeEventListener(\"message\", onMessages);\n    };\n  }, [agent, useChatHelpers.setMessages]);\n\n  // Wrapper that sends only when the last pending confirmation is resolved\n  const addToolResultAndSendMessage: typeof useChatHelpers.addToolResult =\n    async (args) => {\n      const { toolCallId } = args;\n\n      await useChatHelpers.addToolResult(args);\n\n      if (!autoSendAfterAllConfirmationsResolved) {\n        // always send immediately\n        useChatHelpers.sendMessage();\n        return;\n      }\n\n      // wait for all confirmations\n      const pending = pendingConfirmationsRef.current?.toolCallIds;\n      if (!pending) {\n        useChatHelpers.sendMessage();\n        return;\n      }\n\n      const wasLast = pending.size === 1 && pending.has(toolCallId);\n      if (pending.has(toolCallId)) {\n        pending.delete(toolCallId);\n      }\n\n      if (wasLast || pending.size === 0) {\n        useChatHelpers.sendMessage();\n      }\n    };\n\n  return {\n    ...useChatHelpers,\n    addToolResult: addToolResultAndSendMessage,\n    clearHistory: () => {\n      useChatHelpers.setMessages([]);\n      agent.send(\n        JSON.stringify({\n          type: MessageType.CF_AGENT_CHAT_CLEAR\n        })\n      );\n    },\n    setMessages: (\n      messages: Parameters<typeof useChatHelpers.setMessages>[0]\n    ) => {\n      useChatHelpers.setMessages(messages);\n      agent.send(\n        JSON.stringify({\n          messages: Array.isArray(messages) ? messages : [],\n          type: MessageType.CF_AGENT_CHAT_MESSAGES\n        })\n      );\n    }\n  };\n}\n"],"mappings":"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"}